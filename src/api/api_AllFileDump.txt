Folder and File Content Report
Root folder: D:\xbytechat\xbytechat-ui\src\api
Generated at: 10-12-2025 13:05:43.67
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\axiosClient.js 
====================================================== 
 
// ðŸ“„ src/api/axiosClient.js
import axios from "axios";
import { toast } from "react-toastify";
import { requestUpgrade } from "../utils/upgradeBus"; // â† src/api â†’ ../utils âœ…

// ---------------- Base URL (env overrideable) ----------------
const rawBase =
  (process.env.REACT_APP_API_BASE_URL &&
    process.env.REACT_APP_API_BASE_URL.trim()) ||
  "http://localhost:7113/api";

function normalizeBaseUrl(url) {
  const u = (url || "").replace(/\/+$/, ""); // strip trailing slashes
  return u.endsWith("/api") ? u : `${u}/api`;
}

const apiBaseUrl = normalizeBaseUrl(rawBase);

// ---------------- Token key (single source of truth) --------
export const TOKEN_KEY = "xbyte_token";

// ---------------- Axios instance ----------------------------
const axiosClient = axios.create({
  baseURL: apiBaseUrl,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
  withCredentials: false, // using Bearer tokens, not cookies
});

// Attach Authorization header if token exists
axiosClient.interceptors.request.use(config => {
  const token = localStorage.getItem(TOKEN_KEY);
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

// ---------------- Helpers -----------------------------------
const AUTH_PAGES = [
  "/login",
  "/signup",
  "/pending-approval",
  "/profile-completion",
];
const isOnAuthPage = () =>
  AUTH_PAGES.some(p => (window.location?.pathname || "").startsWith(p));

let showingAuthToast = false; // 401 / generic / 403 (generic)
let showingQuotaToast = false; // 429

// 403 subscription set (server-side [RequireActiveSubscription] style)
const SUBSCRIPTION_STATUS_CODES = [
  "trialexpired",
  "pastdue",
  "suspended",
  "cancelled",
  "expired",
  "noactivesubscription",
  "noplan",
  "paymentrequired",
];

function isSubscriptionAccessError(error) {
  if (!error?.response) return false;
  const { status, data } = error.response;
  if (status !== 403 || !data) return false;
  if (data.ok !== false) return false;

  const code = String(
    data.status || data.code || data.errorCode || ""
  ).toLowerCase();
  return !!code && SUBSCRIPTION_STATUS_CODES.includes(code);
}

function handleSubscriptionAccessError(error, { suppress403 }) {
  const { data } = error.response || {};
  const message =
    data?.message || "Your subscription does not allow access to this feature.";

  const path = window.location?.pathname || "";
  const onBilling =
    path.startsWith("/app/settings/billing") ||
    path.startsWith("/app/payment/status");

  if (!suppress403 && !showingAuthToast) {
    toast.error(message, { toastId: "subscription-403" });
    showingAuthToast = true;
    setTimeout(() => (showingAuthToast = false), 1500);
  }

  if (!suppress403 && !isOnAuthPage() && !onBilling) {
    setTimeout(() => {
      window.location.href = "/app/settings/billing";
    }, 800);
  }
}

// 403 feature/permission denial (upgrade flow)
const FEATURE_FORBIDDEN_CODES = [
  "featuredenied",
  "feature_denied",
  "featuredisabled",
  "feature_disabled",
  "permissiondenied",
  "permission_denied",
  "forbidden_feature",
];

function isFeatureForbidden403(error) {
  if (!error?.response) return false;
  const { status, data } = error.response;
  if (status !== 403 || !data) return false;
  if (isSubscriptionAccessError(error)) return false;

  const lower = v => String(v || "").toLowerCase();
  const code = lower(data.code || data.errorCode || data.status || data.reason);

  if (FEATURE_FORBIDDEN_CODES.includes(code)) return true;

  const msg = lower(data.message);
  if (!msg) return false;
  return (
    (msg.includes("feature") &&
      (msg.includes("denied") || msg.includes("disabled"))) ||
    (msg.includes("permission") && msg.includes("denied"))
  );
}

function handleFeatureForbidden403(error, { suppress403 }) {
  const data = error?.response?.data || {};
  const featureCode =
    data.featureCode ||
    data.permissionCode ||
    data.code ||
    data.errorCode ||
    data.reason ||
    null;

  const message =
    data?.message ||
    "This feature isnâ€™t available on your current plan. Upgrade to continue.";

  if (!suppress403 && !showingAuthToast) {
    toast.warn(message, { toastId: "feature-403", autoClose: 4000 });
    showingAuthToast = true;
    setTimeout(() => (showingAuthToast = false), 1500);
  }

  // Fire global upgrade modal
  try {
    requestUpgrade({ reason: "feature", code: featureCode });
  } catch {
    // If the bus isn't mounted yet, fail soft
  }

  const path = window.location?.pathname || "";
  const onBilling =
    path.startsWith("/app/settings/billing") ||
    path.startsWith("/app/payment/status");

  if (!suppress403 && !isOnAuthPage() && !onBilling) {
    setTimeout(() => {
      window.location.href = "/app/settings/billing?source=feature";
    }, 800);
  }
}

// 429 quota/entitlement denial
function isQuotaDenial429(error) {
  return !!error?.response && error.response.status === 429;
}

function handleQuotaDenial429(error, { suppress429 }) {
  const data = error?.response?.data || {};
  const reason = String(data.reason || "").toUpperCase() || "QUOTA_LIMIT";
  const quotaKey = data.quotaKey || data.key || data.code || null;

  const msg =
    data?.message ||
    (quotaKey
      ? `Limit reached for ${quotaKey}. Consider upgrading your plan.`
      : `You're out of quota for this action. Consider upgrading your plan.`);

  if (!suppress429 && !showingQuotaToast) {
    toast.warn(msg, { toastId: "quota-429", autoClose: 5000 });
    showingQuotaToast = true;
    setTimeout(() => (showingQuotaToast = false), 1500);
  }

  // Trigger upgrade flow
  try {
    requestUpgrade({ reason: "quota", code: quotaKey || reason });
  } catch {
    // ignore
  }

  // breadcrumb for UI (e.g., Billing page can read & show details)
  try {
    sessionStorage.setItem(
      "last_quota_denial",
      JSON.stringify({
        at: new Date().toISOString(),
        reason,
        quotaKey,
        path: error?.config?.url || "",
      })
    );
  } catch {}

  const path = window.location?.pathname || "";
  const onBilling =
    path.startsWith("/app/settings/billing") ||
    path.startsWith("/app/payment/status");

  if (!suppress429 && !isOnAuthPage() && !onBilling) {
    setTimeout(() => {
      window.location.href = "/app/settings/billing?source=quota";
    }, 800);
  }
}

// ---------------- Response interceptor ----------------------
axiosClient.interceptors.response.use(
  res => res,
  error => {
    const status = error?.response?.status;
    const msg =
      error?.response?.data?.message ||
      error?.message ||
      "âŒ Something went wrong.";

    const cfg = error?.config || {};
    const suppress401 =
      cfg.__silent401 ||
      cfg.headers?.["x-suppress-401-toast"] ||
      isOnAuthPage();
    const suppress403 =
      cfg.__silent403 ||
      cfg.headers?.["x-suppress-403-toast"] ||
      isOnAuthPage();
    const suppress429 =
      cfg.__silent429 || cfg.headers?.["x-suppress-429-toast"] || false;

    // ðŸ” Detect login / signup calls so we don't redirect those 401s
    const isLoginCall =
      typeof cfg.url === "string" &&
      (cfg.url.includes("/auth/login") || cfg.url.includes("/auth/signup"));

    // 401 â†’ clear token, soft-redirect to login (except for /auth/login itself)
    if (status === 401) {
      // Let normal login errors bubble up to the login form
      if (isLoginCall) {
        return Promise.reject(error);
      }

      localStorage.removeItem(TOKEN_KEY);

      // Mark that this was a session-expired redirect
      try {
        sessionStorage.setItem("auth_last_reason", "session-expired");
      } catch {
        // ignore
      }

      if (!suppress401 && !showingAuthToast) {
        toast.error("â° Session expired. Please log in again.");
        showingAuthToast = true;
        setTimeout(() => (showingAuthToast = false), 2000);
      }

      if (!suppress401 && !isOnAuthPage()) {
        const redirectTo = encodeURIComponent(
          (window.location?.pathname || "") +
            (window.location?.search || "") +
            (window.location?.hash || "")
        );
        // include reason=session-expired so Login page can show a banner
        window.location.href = `/login?reason=session-expired&redirectTo=${redirectTo}`;
      }

      return Promise.reject(error);
    }

    // 403 â†’ subscription vs feature vs generic forbidden
    if (status === 403) {
      if (isSubscriptionAccessError(error)) {
        handleSubscriptionAccessError(error, { suppress403 });
      } else if (isFeatureForbidden403(error)) {
        handleFeatureForbidden403(error, { suppress403 });
      } else {
        if (!suppress403 && !showingAuthToast) {
          toast.error("â›” Access denied.");
          showingAuthToast = true;
          setTimeout(() => (showingAuthToast = false), 2000);
        }
      }
      return Promise.reject(error);
    }

    // 429 â†’ quota/entitlement denial
    if (isQuotaDenial429(error)) {
      handleQuotaDenial429(error, { suppress429 });
      return Promise.reject(error);
    }

    // Generic non-401/403/429
    if (!showingAuthToast) {
      toast.error(msg);
      showingAuthToast = true;
      setTimeout(() => (showingAuthToast = false), 1500);
    }

    if (process.env.NODE_ENV !== "production") {
      // eslint-disable-next-line no-console
      console.error("[Axios Error]", error);
    }

    return Promise.reject(error);
  }
);

if (process.env.NODE_ENV !== "production") {
  // eslint-disable-next-line no-console
  console.log("âœ… Axios BASE URL:", axiosClient.defaults.baseURL);
}

export default axiosClient;

// // ðŸ“„ src/api/axiosClient.js
// import axios from "axios";
// import { toast } from "react-toastify";
// import { requestUpgrade } from "../utils/upgradeBus"; // â† src/api â†’ ../utils âœ…

// // ---------------- Base URL (env overrideable) ----------------
// const rawBase =
//   (process.env.REACT_APP_API_BASE_URL &&
//     process.env.REACT_APP_API_BASE_URL.trim()) ||
//   "http://localhost:7113/api";

// function normalizeBaseUrl(url) {
//   const u = (url || "").replace(/\/+$/, ""); // strip trailing slashes
//   return u.endsWith("/api") ? u : `${u}/api`;
// }

// const apiBaseUrl = normalizeBaseUrl(rawBase);

// // ---------------- Token key (single source of truth) --------
// export const TOKEN_KEY = "xbyte_token";

// // ---------------- Axios instance ----------------------------
// const axiosClient = axios.create({
//   baseURL: apiBaseUrl,
//   headers: {
//     "Content-Type": "application/json",
//     Accept: "application/json",
//   },
//   withCredentials: false, // using Bearer tokens, not cookies
// });

// // Attach Authorization header if token exists
// axiosClient.interceptors.request.use(config => {
//   const token = localStorage.getItem(TOKEN_KEY);
//   if (token) config.headers.Authorization = `Bearer ${token}`;
//   return config;
// });

// // ---------------- Helpers -----------------------------------
// const AUTH_PAGES = [
//   "/login",
//   "/signup",
//   "/pending-approval",
//   "/profile-completion",
// ];
// const isOnAuthPage = () =>
//   AUTH_PAGES.some(p => (window.location?.pathname || "").startsWith(p));

// let showingAuthToast = false; // 401 / generic / 403 (generic)
// let showingQuotaToast = false; // 429

// // 403 subscription set (server-side [RequireActiveSubscription] style)
// const SUBSCRIPTION_STATUS_CODES = [
//   "trialexpired",
//   "pastdue",
//   "suspended",
//   "cancelled",
//   "expired",
//   "noactivesubscription",
//   "noplan",
//   "paymentrequired",
// ];

// function isSubscriptionAccessError(error) {
//   if (!error?.response) return false;
//   const { status, data } = error.response;
//   if (status !== 403 || !data) return false;
//   if (data.ok !== false) return false;

//   const code = String(
//     data.status || data.code || data.errorCode || ""
//   ).toLowerCase();
//   return !!code && SUBSCRIPTION_STATUS_CODES.includes(code);
// }

// function handleSubscriptionAccessError(error, { suppress403 }) {
//   const { data } = error.response || {};
//   const message =
//     data?.message || "Your subscription does not allow access to this feature.";

//   const path = window.location?.pathname || "";
//   const onBilling =
//     path.startsWith("/app/settings/billing") ||
//     path.startsWith("/app/payment/status");

//   if (!suppress403 && !showingAuthToast) {
//     toast.error(message, { toastId: "subscription-403" });
//     showingAuthToast = true;
//     setTimeout(() => (showingAuthToast = false), 1500);
//   }

//   if (!suppress403 && !isOnAuthPage() && !onBilling) {
//     setTimeout(() => {
//       window.location.href = "/app/settings/billing";
//     }, 800);
//   }
// }

// // 403 feature/permission denial (upgrade flow)
// const FEATURE_FORBIDDEN_CODES = [
//   "featuredenied",
//   "feature_denied",
//   "featuredisabled",
//   "feature_disabled",
//   "permissiondenied",
//   "permission_denied",
//   "forbidden_feature",
// ];

// function isFeatureForbidden403(error) {
//   if (!error?.response) return false;
//   const { status, data } = error.response;
//   if (status !== 403 || !data) return false;
//   if (isSubscriptionAccessError(error)) return false;

//   const lower = v => String(v || "").toLowerCase();
//   const code = lower(data.code || data.errorCode || data.status || data.reason);

//   if (FEATURE_FORBIDDEN_CODES.includes(code)) return true;

//   const msg = lower(data.message);
//   if (!msg) return false;
//   return (
//     (msg.includes("feature") &&
//       (msg.includes("denied") || msg.includes("disabled"))) ||
//     (msg.includes("permission") && msg.includes("denied"))
//   );
// }

// function handleFeatureForbidden403(error, { suppress403 }) {
//   const data = error?.response?.data || {};
//   const featureCode =
//     data.featureCode ||
//     data.permissionCode ||
//     data.code ||
//     data.errorCode ||
//     data.reason ||
//     null;

//   const message =
//     data?.message ||
//     "This feature isnâ€™t available on your current plan. Upgrade to continue.";

//   if (!suppress403 && !showingAuthToast) {
//     toast.warn(message, { toastId: "feature-403", autoClose: 4000 });
//     showingAuthToast = true;
//     setTimeout(() => (showingAuthToast = false), 1500);
//   }

//   // Fire global upgrade modal
//   try {
//     requestUpgrade({ reason: "feature", code: featureCode });
//   } catch {
//     // If the bus isn't mounted yet, fail soft
//   }

//   const path = window.location?.pathname || "";
//   const onBilling =
//     path.startsWith("/app/settings/billing") ||
//     path.startsWith("/app/payment/status");

//   if (!suppress403 && !isOnAuthPage() && !onBilling) {
//     setTimeout(() => {
//       window.location.href = "/app/settings/billing?source=feature";
//     }, 800);
//   }
// }

// // 429 quota/entitlement denial
// function isQuotaDenial429(error) {
//   return !!error?.response && error.response.status === 429;
// }

// function handleQuotaDenial429(error, { suppress429 }) {
//   const data = error?.response?.data || {};
//   const reason = String(data.reason || "").toUpperCase() || "QUOTA_LIMIT";
//   const quotaKey = data.quotaKey || data.key || data.code || null;

//   const msg =
//     data?.message ||
//     (quotaKey
//       ? `Limit reached for ${quotaKey}. Consider upgrading your plan.`
//       : `You're out of quota for this action. Consider upgrading your plan.`);

//   if (!suppress429 && !showingQuotaToast) {
//     toast.warn(msg, { toastId: "quota-429", autoClose: 5000 });
//     showingQuotaToast = true;
//     setTimeout(() => (showingQuotaToast = false), 1500);
//   }

//   // Trigger upgrade flow
//   try {
//     requestUpgrade({ reason: "quota", code: quotaKey || reason });
//   } catch {
//     // ignore
//   }

//   // breadcrumb for UI (e.g., Billing page can read & show details)
//   try {
//     sessionStorage.setItem(
//       "last_quota_denial",
//       JSON.stringify({
//         at: new Date().toISOString(),
//         reason,
//         quotaKey,
//         path: error?.config?.url || "",
//       })
//     );
//   } catch {}

//   const path = window.location?.pathname || "";
//   const onBilling =
//     path.startsWith("/app/settings/billing") ||
//     path.startsWith("/app/payment/status");

//   if (!suppress429 && !isOnAuthPage() && !onBilling) {
//     setTimeout(() => {
//       window.location.href = "/app/settings/billing?source=quota";
//     }, 800);
//   }
// }

// // ---------------- Response interceptor ----------------------
// axiosClient.interceptors.response.use(
//   res => res,
//   error => {
//     const status = error?.response?.status;
//     const msg =
//       error?.response?.data?.message ||
//       error?.message ||
//       "âŒ Something went wrong.";

//     const cfg = error?.config || {};
//     const suppress401 =
//       cfg.__silent401 ||
//       cfg.headers?.["x-suppress-401-toast"] ||
//       isOnAuthPage();
//     const suppress403 =
//       cfg.__silent403 ||
//       cfg.headers?.["x-suppress-403-toast"] ||
//       isOnAuthPage();
//     const suppress429 =
//       cfg.__silent429 || cfg.headers?.["x-suppress-429-toast"] || false;

//     // 401 â†’ clear token, soft-redirect to login
//     if (status === 401) {
//       localStorage.removeItem(TOKEN_KEY);

//       if (!suppress401 && !showingAuthToast) {
//         toast.error("â° Session expired. Please log in again.");
//         showingAuthToast = true;
//         setTimeout(() => (showingAuthToast = false), 2000);
//       }

//       if (!suppress401 && !isOnAuthPage()) {
//         const redirectTo = encodeURIComponent(
//           (window.location?.pathname || "") +
//             (window.location?.search || "") +
//             (window.location?.hash || "")
//         );
//         window.location.href = `/login?redirectTo=${redirectTo}`;
//       }

//       return Promise.reject(error);
//     }

//     // 403 â†’ subscription vs feature vs generic forbidden
//     if (status === 403) {
//       if (isSubscriptionAccessError(error)) {
//         handleSubscriptionAccessError(error, { suppress403 });
//       } else if (isFeatureForbidden403(error)) {
//         handleFeatureForbidden403(error, { suppress403 });
//       } else {
//         if (!suppress403 && !showingAuthToast) {
//           toast.error("â›” Access denied.");
//           showingAuthToast = true;
//           setTimeout(() => (showingAuthToast = false), 2000);
//         }
//       }
//       return Promise.reject(error);
//     }

//     // 429 â†’ quota/entitlement denial
//     if (isQuotaDenial429(error)) {
//       handleQuotaDenial429(error, { suppress429 });
//       return Promise.reject(error);
//     }

//     // Generic non-401/403/429
//     if (!showingAuthToast) {
//       toast.error(msg);
//       showingAuthToast = true;
//       setTimeout(() => (showingAuthToast = false), 1500);
//     }

//     if (process.env.NODE_ENV !== "production") {
//       // eslint-disable-next-line no-console
//       console.error("[Axios Error]", error);
//     }

//     return Promise.reject(error);
//   }
// );

// if (process.env.NODE_ENV !== "production") {
//   // eslint-disable-next-line no-console
//   console.log("âœ… Axios BASE URL:", axiosClient.defaults.baseURL);
// }

// export default axiosClient;
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\dashboardService.js 
====================================================== 
 
import axiosClient from "./axiosClient";

/**
 * Fetches the main campaign status dashboard data.
 */
export const getCampaignStatusDashboard = () => {
  return axiosClient.get("/CampaignAnalytics/status-dashboard");
};

/**
 * Fetches the top performing campaigns.
 * @param {number} count The number of top campaigns to fetch.
 */
export const getTopCampaigns = (count = 5) => {
  return axiosClient.get(`/CampaignAnalytics/top-campaigns?count=${count}`);
};
export const getCrmSummary = () => {
  return axiosClient.get("/CrmAnalytics/summary");
};

/**
 * Fetches the daily new contact trend data for the last 30 days.
 */
export const getCrmContactTrends = () => {
  return axiosClient.get("/CrmAnalytics/contact-trends");
};
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\permissions.js 
====================================================== 
 
// ðŸ“„ src/api/permissions.js

import axiosClient from "./axiosClient";

// Flat list (unchanged behavior)
export const getAllPermissions = () => axiosClient.get("/permissions");

// Grouped list â€“ tolerant to different backend routes,
// but still returns a plain array for the UI.
export const getGroupedPermissions = async () => {
  const paths = [
    "/permission/grouped",
    "/Permission/grouped",
    "/api/Permission/grouped", // legacy, if your backend still uses this
  ];

  let lastErr;

  for (const p of paths) {
    try {
      const res = await axiosClient.get(p);

      // Normalize to "array of groups"
      const data = res?.data;
      if (Array.isArray(data?.data)) return data.data;
      if (Array.isArray(data)) return data;

      // Some backends might return { groups: [...] }
      if (Array.isArray(data?.groups)) return data.groups;

      // If the whole response is already an array
      if (Array.isArray(res)) return res;

      return [];
    } catch (err) {
      const status = err?.response?.status;
      if (status === 404 || status === 405) {
        lastErr = err;
        continue; // try next path
      }
      throw err; // real error, stop
    }
  }

  throw lastErr ?? new Error("No grouped-permissions endpoint responded.");
};

// CRUD
export const createPermission = dto =>
  axiosClient.post("/Permission", {
    ...dto,
    code: String(dto.code || "")
      .trim()
      .toUpperCase()
      .replace(/\s+/g, "_"),
  });

export const updatePermission = (id, dto) =>
  axiosClient.put(`/Permission/${id}`, dto);

export const togglePermissionActive = (id, isActive) =>
  axiosClient.patch(`/Permission/${id}/status`, { isActive });

export const deletePermission = id => axiosClient.delete(`/Permission/${id}`);

// import axiosClient from "../utils/axiosClient";

// // Flat list (unchanged behavior)
// export const getAllPermissions = () => axiosClient.get("/permissions");

// // Grouped list (more tolerant: supports data.data OR data)
// export const getGroupedPermissions = async () => {
//   const res = await axiosClient.get("/api/Permission/grouped");
//   return Array.isArray(res?.data?.data)
//     ? res.data.data
//     : Array.isArray(res?.data)
//     ? res.data
//     : [];
// };

// // CRUD
// export const createPermission = dto =>
//   axiosClient.post("/api/Permission", {
//     ...dto,
//     code: String(dto.code || "")
//       .trim()
//       .toUpperCase()
//       .replace(/\s+/g, "_"),
//   });

// export const updatePermission = (id, dto) =>
//   axiosClient.put(`/api/Permission/${id}`, dto);

// export const togglePermissionActive = (id, isActive) =>
//   axiosClient.patch(`/api/Permission/${id}/status`, { isActive });

// export const deletePermission = id =>
//   axiosClient.delete(`/api/Permission/${id}`);

// import axiosClient from "../utils/axiosClient";

// export const getAllPermissions = () => axiosClient.get("/permissions");
// export const getGroupedPermissions = async () => {
//   const response = await axiosClient.get("/api/Permission/grouped");
//   return response.data.data; // <- this ensures you're extracting the nested `data` key
// };
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\plans.js 
====================================================== 
 
// ðŸ“„ src/api/plans.js
import axiosClient from "../api/axiosClient";

// ---------- internal: multi-path fallback (404 or 405) ----------
async function tryPaths(method, paths, payload) {
  let lastErr;
  for (const p of paths) {
    try {
      if (method === "get") return await axiosClient.get(p);
      if (method === "post") return await axiosClient.post(p, payload);
      if (method === "put") return await axiosClient.put(p, payload);
      if (method === "delete") return await axiosClient.delete(p);
      throw new Error(`Unsupported method: ${method}`);
    } catch (err) {
      const status = err?.response?.status;
      // Only fall back on "not found" or "method not allowed"
      if (status === 404 || status === 405) {
        lastErr = err;
        continue;
      }
      throw err;
    }
  }
  // Exhausted every path
  throw lastErr ?? new Error("No valid API path responded successfully.");
}

// Convenience wrappers
const getTry = (...paths) => tryPaths("get", paths.flat());
const postTry = (paths, payload) => tryPaths("post", paths, payload);
const putTry = (paths, payload) => tryPaths("put", paths, payload);
const deleteTry = (...paths) => tryPaths("delete", paths.flat());

// ---------- Plans (support singular/plural + casing) ----------
export const getPlans = () => getTry(["/plan", "/Plan", "/plans", "/Plans"]);

export const createPlan = payload => postTry(["/plan", "/Plan"], payload);

export const updatePlan = (planId, payload) =>
  putTry(
    [
      `/plan/${planId}`,
      `/Plan/${planId}`,
      `/plans/${planId}`,
      `/Plans/${planId}`,
    ],
    payload
  );

export const deletePlan = planId =>
  deleteTry([
    `/plan/${planId}`,
    `/Plan/${planId}`,
    `/plans/${planId}`,
    `/Plans/${planId}`,
  ]);

// ---------- Plan â†” Permission mapping ----------
export const getPlanPermissions = planId =>
  getTry([`/plan/${planId}/permissions`, `/Plan/${planId}/permissions`]);

// Ensure we always send the shape your backend expects and a clean list
function normalizePermissionIds(ids) {
  if (!Array.isArray(ids)) return [];
  const set = new Set(
    ids
      .filter(Boolean)
      .map(x => String(x).trim())
      .filter(x => x.length > 0)
  );
  return Array.from(set);
}

/**
 * Update plan â†” permission mapping.
 *
 * Supports both call styles:
 *   updatePlanPermissions(planId, ["id1", "id2"])
 *   updatePlanPermissions(planId, { permissionIds: [...], replaceAll: true })
 *   updatePlanPermissions(planId, { enabledPermissionIds: [...], replaceAll: true })
 */
export const updatePlanPermissions = (planId, payload, replaceAll = true) => {
  let permissionIds;

  // Case 1: caller passes an array â†’ treat as raw ids
  if (Array.isArray(payload)) {
    permissionIds = payload;
  }
  // Case 2: caller passes an object â†’ expect { permissionIds, replaceAll? }
  else if (payload && typeof payload === "object") {
    permissionIds = payload.permissionIds ?? payload.enabledPermissionIds ?? [];
    if (typeof payload.replaceAll === "boolean") {
      replaceAll = payload.replaceAll;
    }
  } else {
    permissionIds = [];
  }

  return putTry(
    [`/plan/${planId}/permissions`, `/Plan/${planId}/permissions`],
    {
      permissionIds: normalizePermissionIds(permissionIds),
      replaceAll,
    }
  );
};

// ---------- Permission catalog (grouped) ----------
export const getGroupedPermissions = async () => {
  // Prefer lowercase first (your newer endpoints), then PascalCase
  try {
    const res = await axiosClient.get("/permission/grouped");
    // Return array directly for the UI (it maps over it)
    return res?.data?.data ?? res?.data ?? [];
  } catch (err) {
    if (err?.response?.status === 404 || err?.response?.status === 405) {
      const res2 = await axiosClient.get("/Permission/grouped");
      return res2?.data?.data ?? res2?.data ?? [];
    }
    throw err;
  }
};

// ---------- Plan â†” Quotas mapping (new) ----------
// These talk to: GET/PUT /admin/plans/{planId}/quotas (with fallbacks)

export const getPlanQuotas = planId =>
  getTry([
    `/admin/plans/${planId}/quotas`,
    `/plans/${planId}/quotas`,
    `/Plans/${planId}/quotas`,
  ]);

export const updatePlanQuotas = (planId, quotas) =>
  putTry(
    [
      `/admin/plans/${planId}/quotas`,
      `/plans/${planId}/quotas`,
      `/Plans/${planId}/quotas`,
    ],
    quotas
  );
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\roles.js 
====================================================== 
 
import api from "./_base"; // your axios instance

export const getRoles = () => api.get("/api/roles");
export const createRole = payload => api.post("/api/roles", payload);
export const updateRole = (id, payload) => api.put(`/api/roles/${id}`, payload);
export const deleteRole = id => api.delete(`/api/roles/${id}`);

// returns: array of permission objects OR codes
export const getRolePermissions = roleId =>
  api.get(`/roles/${roleId}/permissions`);

// body: array of permissionIds (GUIDs)
export const updateRolePermissions = (roleId, permissionIds) =>
  api.put(`/roles/${roleId}/permissions`, { permissionIds });
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\templateService.js 
====================================================== 
 
import axiosClient from "./axiosClient";

export const fetchTemplates = async businessId => {
  const response = await axiosClient.get(
    `/WhatsAppTemplateFetcher/${businessId}`
  );

  if (Array.isArray(response.data)) {
    // âœ… Direct array received
    return response.data;
  } else if (
    response.data.templates &&
    Array.isArray(response.data.templates)
  ) {
    // âœ… templates inside object
    return response.data.templates;
  } else {
    throw new Error("Unexpected template response format");
  }
};
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\userPermissions.js 
====================================================== 
 
// ðŸ“„ File: src/api/userPermissions.js

import axiosClient from "./axiosClient";

/**
 * Get active UserPermission overrides for a specific user.
 *
 * Backend: GET /api/admin/users/{userId}/permissions
 *
 * Returns an array of:
 * {
 *   permissionId: string;
 *   code: string;
 *   name: string;
 *   isGranted: boolean;
 *   isRevoked: boolean;
 *   assignedAt: string;
 *   assignedBy: string | null;
 * }
 */
export async function getUserPermissionOverrides(userId) {
  if (!userId) {
    throw new Error("getUserPermissionOverrides: userId is required");
  }

  const res = await axiosClient.get(
    `/admin/users/${encodeURIComponent(userId)}/permissions`
  );
  return res.data;
}

/**
 * Upsert a UserPermission override for a specific user + permission.
 *
 * Backend: POST /api/admin/users/{userId}/permissions
 *
 * Payload:
 * {
 *   permissionId: string;
 *   isGranted: boolean; // true = explicit allow, false = explicit deny
 * }
 *
 * Returns the updated override DTO (same shape as GET).
 */
export async function upsertUserPermissionOverride(userId, payload) {
  if (!userId) {
    throw new Error("upsertUserPermissionOverride: userId is required");
  }
  if (!payload?.permissionId) {
    throw new Error(
      "upsertUserPermissionOverride: payload.permissionId is required"
    );
  }

  const res = await axiosClient.post(
    `/admin/users/${encodeURIComponent(userId)}/permissions`,
    {
      permissionId: payload.permissionId,
      isGranted: payload.isGranted,
    }
  );
  return res.data;
}

/**
 * Clear (soft delete) a UserPermission override so the user
 * falls back to their plan-level permission.
 *
 * Backend: DELETE /api/admin/users/{userId}/permissions/{permissionId}
 */
export async function deleteUserPermissionOverride(userId, permissionId) {
  if (!userId) {
    throw new Error("deleteUserPermissionOverride: userId is required");
  }
  if (!permissionId) {
    throw new Error("deleteUserPermissionOverride: permissionId is required");
  }

  const res = await axiosClient.delete(
    `/api/admin/users/${encodeURIComponent(
      userId
    )}/permissions/${encodeURIComponent(permissionId)}`
  );
  return res.data; // could be empty / status only; adjust if needed
}

// Optional namespace export
const userPermissionsApi = {
  getUserPermissionOverrides,
  upsertUserPermissionOverride,
  deleteUserPermissionOverride,
};

export default userPermissionsApi;
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\users.js 
====================================================== 
 
import React, { useEffect, useMemo, useState } from "react";
import { useSearchParams } from "react-router-dom";
import { toast } from "react-toastify";
import { ShieldCheck, UserCog } from "lucide-react";

import { getPlanPermissions } from "../../../api/plans";
import { getGroupedPermissions } from "../../../api/permissions";
import {
  getUserPermissionOverrides,
  upsertUserPermissionOverride,
  deleteUserPermissionOverride,
} from "../../../api/userPermissions";
import { getBusinessUsers } from "../../../api/users";
import { useAuth } from "../../../app/providers/AuthProvider";

/**
 * User Permission Overrides (Admin)
 *
 * Flow:
 * - Business owner opens Settings â†’ "User Access & Permissions".
 * - We detect the current businessId from auth and load all users for that business.
 * - Admin selects a user from a dropdown.
 * - We show plan defaults + per-user overrides (Allow / Deny / Inherit).
 */
export default function UserPermissionOverrides() {
  const [searchParams] = useSearchParams();
  const auth = useAuth();
  const authLoading = auth?.isLoading;

  // --- Auth / context -------------------------------------------------------

  const qsUserId = searchParams.get("userId");
  const qsPlanId = searchParams.get("planId");

  const authUser = auth?.user || auth?.session || auth || {};

  const authUserId = authUser.userId || authUser.id || authUser.sub || null;

  const authBusinessId =
    authUser.businessId || authUser.business_id || auth?.businessId || null;

  const authPlanId =
    authUser.planId || authUser.plan_id || auth?.planId || null;

  const planId = qsPlanId || authPlanId || null;

  // --- Local state ----------------------------------------------------------

  const [users, setUsers] = useState([]);
  const [usersLoading, setUsersLoading] = useState(false);
  const [selectedUserId, setSelectedUserId] = useState(null);

  const [loading, setLoading] = useState(false);
  const [planPermissions, setPlanPermissions] = useState([]);
  const [groupedPermissions, setGroupedPermissions] = useState([]);
  const [userOverrides, setUserOverrides] = useState([]);

  // Selected user object from list
  const selectedUser = useMemo(
    () => users.find(u => u.id === selectedUserId),
    [users, selectedUserId]
  );

  const userContext = {
    displayName:
      selectedUser?.fullName ||
      selectedUser?.name ||
      selectedUser?.email ||
      "No user selected",
    email: selectedUser?.email || "",
    planName:
      authUser.planName ||
      authUser.plan_name ||
      (planId ? "Current Plan" : "Not linked yet"),
  };

  // Map for plan permissions
  const planPermissionMap = useMemo(() => {
    const map = {};
    for (const pp of planPermissions || []) {
      const permissionId =
        pp.permissionId || pp.permissionID || pp.permission?.id;
      if (!permissionId) continue;
      map[permissionId] = pp;
    }
    return map;
  }, [planPermissions]);

  // Map for overrides
  const overrideMap = useMemo(() => {
    const map = {};
    for (const ov of userOverrides || []) {
      if (!ov.permissionId) continue;
      map[ov.permissionId] = ov;
    }
    return map;
  }, [userOverrides]);

  // --- Effect 1: load users for current business ----------------------------

  useEffect(() => {
    if (authLoading) return;
    if (!authBusinessId) {
      console.warn(
        "UserPermissionOverrides: no businessId from auth. Cannot load users."
      );
      return;
    }

    const loadUsers = async () => {
      setUsersLoading(true);
      try {
        const list = await getBusinessUsers(authBusinessId);
        const usersArray = Array.isArray(list)
          ? list
          : Array.isArray(list?.data)
          ? list.data
          : [];

        setUsers(usersArray);

        if (usersArray.length === 0) {
          setSelectedUserId(null);
          return;
        }

        // Priority for default selected user:
        // 1) userId from query string (if present in list)
        // 2) logged-in user (if present in list)
        // 3) first user in list
        const qsMatch = qsUserId && usersArray.find(u => u.id === qsUserId)?.id;

        const authMatch =
          authUserId && usersArray.find(u => u.id === authUserId)?.id;

        const fallback = usersArray[0].id;

        setSelectedUserId(qsMatch || authMatch || fallback);
      } catch (err) {
        console.error("Failed to load business users:", err);
        toast.error("Failed to load users for this account.");
        setUsers([]);
        setSelectedUserId(null);
      } finally {
        setUsersLoading(false);
      }
    };

    loadUsers();
  }, [authLoading, authBusinessId, qsUserId, authUserId]);

  // --- Effect 2: load permissions + overrides for selected user -------------

  useEffect(() => {
    if (authLoading) return;
    if (!selectedUserId) {
      // no user selected â†’ nothing to load yet
      return;
    }

    const loadData = async () => {
      setLoading(true);
      try {
        // Always load grouped permissions + overrides
        const promises = [
          getGroupedPermissions(),
          getUserPermissionOverrides(selectedUserId),
        ];

        if (planId) {
          promises.push(getPlanPermissions(planId));
        }

        const [groupedRes, overridesRes, planPermRes] = await Promise.all(
          promises
        );

        // Normalise groups
        let groups = [];
        if (Array.isArray(groupedRes)) {
          groups = groupedRes;
        } else if (Array.isArray(groupedRes?.groups)) {
          groups = groupedRes.groups;
        } else if (Array.isArray(groupedRes?.data)) {
          groups = groupedRes.data;
        }
        setGroupedPermissions(groups || []);

        setUserOverrides(overridesRes || []);

        if (planPermRes) {
          const list = Array.isArray(planPermRes)
            ? planPermRes
            : Array.isArray(planPermRes?.items)
            ? planPermRes.items
            : planPermRes.data || [];
          setPlanPermissions(list || []);
        } else {
          setPlanPermissions([]);
        }
      } catch (err) {
        console.error("Failed to load permission data:", err);
        toast.error("Failed to load permission data.");
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [selectedUserId, planId, authLoading]);

  // --- Helpers --------------------------------------------------------------

  function getPermissionState(permissionId) {
    const ov = overrideMap[permissionId];
    if (ov && ov.isRevoked !== true) {
      return ov.isGranted ? "allow" : "deny";
    }
    return "inherit";
  }

  async function handleSetOverride(permissionId, targetState) {
    if (!selectedUserId) {
      toast.warn("Select a user first before changing overrides.");
      return;
    }

    try {
      if (targetState === "inherit") {
        await deleteUserPermissionOverride(selectedUserId, permissionId);
        setUserOverrides(prev =>
          prev.filter(ov => ov.permissionId !== permissionId)
        );
        toast.success("Override cleared. Using plan default.");
      } else {
        const isGranted = targetState === "allow";
        const updated = await upsertUserPermissionOverride(selectedUserId, {
          permissionId,
          isGranted,
        });

        setUserOverrides(prev => {
          const idx = prev.findIndex(ov => ov.permissionId === permissionId);
          if (idx >= 0) {
            const copy = [...prev];
            copy[idx] = updated;
            return copy;
          }
          return [...prev, updated];
        });

        toast.success(
          isGranted
            ? "Permission explicitly allowed for this user."
            : "Permission explicitly denied for this user."
        );
      }
    } catch (err) {
      console.error("Failed to update override:", err);
      toast.error("Failed to update user permission override.");
    }
  }

  // If we truly have no businessId, explain to the developer
  if (!authLoading && !authBusinessId) {
    return (
      <div className="p-6">
        <div className="max-w-xl bg-white border border-slate-200 rounded-2xl p-6 shadow-sm">
          <h1 className="text-lg font-semibold text-slate-900 mb-2">
            User Permission Overrides
          </h1>
          <p className="text-sm text-slate-600">
            This page could not determine the current business from the auth
            context.
          </p>
          <p className="text-sm text-slate-600 mt-2">
            As a developer, please ensure <code>useAuth()</code> exposes a{" "}
            <code>businessId</code> or <code>user.businessId</code> field.
          </p>
        </div>
      </div>
    );
  }

  // --- UI -------------------------------------------------------------------

  return (
    <div className="p-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold text-slate-900 flex items-center gap-2">
            <ShieldCheck className="w-5 h-5 text-emerald-500" />
            User Permission Overrides
          </h1>
          <p className="text-sm text-slate-600 mt-1">
            Create users for your account, then fine-tune access for each user
            by allowing, denying, or inheriting from the plan.
          </p>
        </div>
      </div>

      {/* Main layout */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* User context */}
        <div className="lg:col-span-1">
          <div className="bg-white border border-slate-200 rounded-2xl p-4 shadow-sm h-full">
            <div className="flex items-start gap-3">
              <div className="p-2 rounded-xl bg-emerald-50 text-emerald-700">
                <UserCog className="w-5 h-5" />
              </div>
              <div className="space-y-1">
                <h2 className="text-sm font-semibold text-slate-900">
                  User Context
                </h2>
                <p className="text-sm text-slate-900">
                  {userContext.displayName}
                </p>
                {userContext.email && (
                  <p className="text-xs text-slate-500">{userContext.email}</p>
                )}
                <p className="text-xs text-slate-600 mt-2">
                  Plan:{" "}
                  <span className="inline-flex items-center px-2 py-0.5 rounded-full bg-emerald-50 text-emerald-700 border border-emerald-100 text-[11px]">
                    {userContext.planName}
                  </span>
                </p>
              </div>
            </div>

            <div className="mt-4 border-t border-slate-200 pt-3 text-xs text-slate-600 space-y-1">
              <div className="flex items-center gap-2">
                <span className="w-2 h-2 rounded-full bg-slate-400" />
                <span>Inherited: follow the plan-level setting.</span>
              </div>
              <div className="flex items-center gap-2">
                <span className="w-2 h-2 rounded-full bg-emerald-500" />
                <span>Allow: explicitly grant this permission.</span>
              </div>
              <div className="flex items-center gap-2">
                <span className="w-2 h-2 rounded-full bg-rose-500" />
                <span>Deny: explicitly block this permission.</span>
              </div>
            </div>
          </div>
        </div>

        {/* Permissions + user selector */}
        <div className="lg:col-span-2">
          <div className="bg-white border border-slate-200 rounded-2xl p-4 shadow-sm">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-3">
              <h2 className="text-sm font-semibold text-slate-900">
                Permission overrides
              </h2>

              <div className="flex items-center gap-2">
                <span className="text-xs text-slate-600">User:</span>
                {usersLoading ? (
                  <span className="text-xs text-slate-500 animate-pulse">
                    Loading usersâ€¦
                  </span>
                ) : users.length === 0 ? (
                  <span className="text-xs text-slate-500">
                    No users yet. Create a user first.
                  </span>
                ) : (
                  <select
                    value={selectedUserId || ""}
                    onChange={e => setSelectedUserId(e.target.value || null)}
                    className="text-xs border border-slate-300 rounded-md px-2 py-1 bg-white text-slate-900"
                  >
                    {users.map(u => (
                      <option key={u.id} value={u.id}>
                        {u.fullName || u.name || u.email}{" "}
                        {u.role ? `(${u.role})` : ""}
                      </option>
                    ))}
                  </select>
                )}
              </div>
            </div>

            {/* If no users at all â†’ empty state, don't show matrix */}
            {users.length === 0 ? (
              <div className="mt-4 rounded-xl border border-dashed border-slate-300 bg-slate-50 p-4 text-sm text-slate-600">
                This account doesnâ€™t have any team users yet.
                <br />
                Create at least one user, then return here to adjust their
                access.
              </div>
            ) : groupedPermissions.length === 0 ? (
              <p className="text-sm text-slate-500">
                No permissions found. Please check the permissions catalog
                configuration.
              </p>
            ) : (
              <div className="space-y-4 max-h-[620px] overflow-auto pr-2">
                {groupedPermissions.map(group => (
                  <div
                    key={group.key || group.code || group.name}
                    className="border border-slate-200 rounded-xl bg-slate-50/60"
                  >
                    <div className="px-4 py-2 border-b border-slate-200 bg-slate-100 flex items-center justify-between">
                      <div>
                        <p className="text-xs font-semibold text-slate-900">
                          {group.label || group.name || "Permission Group"}
                        </p>
                        {group.description && (
                          <p className="text-[11px] text-slate-600">
                            {group.description}
                          </p>
                        )}
                      </div>
                    </div>

                    <div className="divide-y divide-slate-200">
                      {(group.permissions || group.items || []).map(perm => {
                        const permissionId =
                          perm.id || perm.permissionId || perm.permissionID;
                        const code = perm.code || perm.key;
                        const name = perm.name || perm.displayName || code;

                        if (!permissionId) return null;

                        const state = getPermissionState(permissionId);
                        const planRow = planPermissionMap[permissionId];

                        const planKnown = !!planRow;
                        const planAllowed =
                          planRow?.isActive === true ||
                          planRow?.isEnabled === true;

                        return (
                          <div
                            key={permissionId}
                            className="px-4 py-3 flex items-center justify-between gap-3"
                          >
                            <div className="min-w-0">
                              <p className="text-sm text-slate-900">{name}</p>
                              <p className="text-xs text-slate-500 truncate">
                                {code}
                              </p>
                              <p className="text-[11px] text-slate-500 mt-1">
                                Plan default:{" "}
                                {!planId || !planKnown ? (
                                  <span className="text-slate-500">
                                    Unknown
                                  </span>
                                ) : planAllowed ? (
                                  <span className="text-emerald-600">
                                    Allowed
                                  </span>
                                ) : (
                                  <span className="text-rose-600">
                                    Disabled
                                  </span>
                                )}
                                {" Â· "}
                                Effective:{" "}
                                {state === "inherit"
                                  ? !planId || !planKnown
                                    ? "Inherit (plan not loaded)"
                                    : planAllowed
                                    ? "Allowed (from plan)"
                                    : "Disabled (from plan)"
                                  : state === "allow"
                                  ? "Explicitly allowed"
                                  : "Explicitly denied"}
                              </p>
                            </div>

                            <div className="flex items-center gap-1 shrink-0">
                              <StateButton
                                label="Inherit"
                                size="sm"
                                active={state === "inherit"}
                                onClick={() =>
                                  handleSetOverride(permissionId, "inherit")
                                }
                              />
                              <StateButton
                                label="Allow"
                                size="sm"
                                intent="success"
                                active={state === "allow"}
                                onClick={() =>
                                  handleSetOverride(permissionId, "allow")
                                }
                              />
                              <StateButton
                                label="Deny"
                                size="sm"
                                intent="danger"
                                active={state === "deny"}
                                onClick={() =>
                                  handleSetOverride(permissionId, "deny")
                                }
                              />
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

function StateButton({
  label,
  active,
  intent = "neutral",
  size = "md",
  onClick,
}) {
  const base =
    "inline-flex items-center justify-center rounded-full border text-xs font-medium transition focus:outline-none focus:ring-1 focus:ring-offset-0 focus:ring-emerald-500";

  const sizeClass = size === "sm" ? "px-3 py-1" : "px-4 py-1.5";

  let colorInactive =
    "border-slate-300 text-slate-600 bg-white hover:bg-slate-100";
  let colorActive = "border-slate-900 text-slate-50 bg-slate-900";

  if (intent === "success") {
    colorActive =
      "border-emerald-500 text-white bg-emerald-500 hover:bg-emerald-600";
  } else if (intent === "danger") {
    colorActive = "border-rose-500 text-white bg-rose-500 hover:bg-rose-600";
  }

  return (
    <button
      type="button"
      onClick={onClick}
      className={`${base} ${sizeClass} ${active ? colorActive : colorInactive}`}
    >
      {label}
    </button>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\ExtrackAllFiles.bat 
====================================================== 
 
@echo off
REM This script will find all files and output their name and content into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh
> "%outputFile%" (echo Folder and File Content Report)
echo. >> "%outputFile%"

REM Loop through all files in the current directory and subdirectories
for /R . %%F in (*.*) do (
    echo ====================================================== >> "%outputFile%"
    echo FILE: %%F >> "%outputFile%"
    echo ====================================================== >> "%outputFile%"
    echo. >> "%outputFile%"
    type "%%F" >> "%outputFile%" 2>nul
    echo. >> "%outputFile%"
    echo. >> "%outputFile%"
)

echo Finished! All content has been extracted to %outputFile% 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\MakeDump.bat 
====================================================== 
 
@echo off
REM This script will find relevant source files and output their names and contents into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh and write a small header
> "%outputFile%" (
    echo Folder and File Content Report
    echo Root folder: %cd%
    echo Generated at: %date% %time%
)
echo. >> "%outputFile%"

REM NOTE:
REM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)
REM This keeps the file smaller and much easier to review.

REM Loop through all relevant files in the current directory and subdirectories
REM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML
for /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (

    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)
    echo "%%F" | findstr /I /C:"\node_modules\" /C:"\bin\" /C:"\obj\" /C:"\.git\" /C:"\dist\" /C:"\.vs\" >nul
    if errorlevel 1 (
        echo ====================================================== >> "%outputFile%"
        echo FILE: %%F >> "%outputFile%"
        echo ====================================================== >> "%outputFile%"
        echo. >> "%outputFile%"
        type "%%F" >> "%outputFile%" 2>nul
        echo. >> "%outputFile%"
        echo. >> "%outputFile%"
    )
)

echo Finished! All content has been extracted to %outputFile%
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\templateBuilder\drafts.js 
====================================================== 
 
// src/api/templateBuilder/drafts.js
import axiosClient from "../../api/axiosClient";

/**
 * @typedef {Object} VariantPayload
 * @property {string} name
 * @property {string} language
 * @property {string} category
 * @property {string} headerType
 * @property {string} headerText
 * @property {string} headerMediaHandle
 * @property {string} bodyText
 * @property {string} footerText
 * @property {Array<Object>} buttons
 * @property {Array<string>} examples
 */

/**
 * GET preview for a draft variant
 * GET /api/template-builder/drafts/{draftId}/preview?language=
 * @param {string} draftId
 * @param {string} language
 * @returns {Promise<Object>} { human, components, category }
 */
export async function getPreview(draftId, language = "en_US") {
  const { data } = await axiosClient.get(
    `/api/template-builder/drafts/${draftId}/preview`,
    { params: { language } }
  );
  return data;
}

/**
 * PUT save/replace variant
 * PUT /api/template-builder/drafts/{draftId}/variant/{language}
 * @param {string} draftId
 * @param {string} language
 * @param {VariantPayload} payload
 * @returns {Promise<void>}
 */
export async function saveVariant(draftId, language, payload) {
  const { data } = await axiosClient.put(
    `/api/template-builder/drafts/${draftId}/variant/${language}`,
    payload
  );
  return data;
}

/**
 * POST submit draft to Meta
 * POST /api/template-builder/drafts/{draftId}/submit
 * @param {string} draftId
 */
export async function submitDraft(draftId) {
  const { data } = await axiosClient.post(
    `/api/template-builder/drafts/${draftId}/submit`
  );
  return data;
}

/**
 * GET draft status (maps to WhatsAppTemplates)
 * GET /api/template-builder/drafts/{draftId}/status
 * @param {string} draftId
 * @returns {Promise<Object>} status object
 */
export async function getStatus(draftId) {
  const { data } = await axiosClient.get(
    `/api/template-builder/drafts/${draftId}/status`
  );
  return data;
}

/**
 * GET name-check
 * GET /api/template-builder/drafts/{draftId}/name-check?language=
 * @param {string} draftId
 * @param {string} language
 * @returns {Promise<{available:boolean,message?:string}>}
 */
export async function nameCheck(draftId, language = "en_US") {
  const { data } = await axiosClient.get(
    `/api/template-builder/drafts/${draftId}/name-check`,
    { params: { language } }
  );
  return data;
}

/**
 * POST duplicate draft
 * POST /api/template-builder/drafts/{draftId}/duplicate
 * @param {string} draftId
 * @returns {Promise<Object>} new draft info
 */
export async function duplicateDraft(draftId) {
  const { data } = await axiosClient.post(
    `/api/template-builder/drafts/${draftId}/duplicate`
  );
  return data;
}

/**
 * DELETE draft
 * DELETE /api/template-builder/drafts/{draftId}
 * @param {string} draftId
 * @returns {Promise<void>}
 */
export async function deleteDraft(draftId) {
  const { data } = await axiosClient.delete(
    `/api/template-builder/drafts/${draftId}`
  );
  return data;
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\templateBuilder\index.js 
====================================================== 
 
// src/api/templateBuilder/index.js
import * as LibraryApi from "./library";
import * as DraftsApi from "./drafts";
import * as UploadsApi from "./uploads";
import * as TemplatesApi from "./templates";

export { LibraryApi, DraftsApi, UploadsApi, TemplatesApi };
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\templateBuilder\library.js 
====================================================== 
 
// src/api/templateBuilder/library.js
import axiosClient from "../../api/axiosClient";

/**
 * @typedef {Object} BrowseParams
 * @property {string} [industry]
 * @property {string} [q]
 * @property {string} [sort]
 * @property {number} [page]
 * @property {number} [pageSize]
 */

/**
 * GET /api/template-builder/library/industries
 * @returns {Promise<string[]>}
 */
export async function getIndustries() {
  const { data } = await axiosClient.get(
    "/api/template-builder/library/industries"
  );
  return data;
}

/**
 * GET /api/template-builder/library/browse
 * @param {BrowseParams} params
 * @returns {Promise<Object>} paginated result { items: [], total, page, pageSize }
 */
export async function browseLibrary(params = {}) {
  const { data } = await axiosClient.get(
    "/api/template-builder/library/browse",
    { params }
  );
  return data;
}

/**
 * GET /api/template-builder/library/item/{itemId}
 * @param {string} itemId
 * @returns {Promise<Object>} Library item
 */
export async function getLibraryItem(itemId) {
  const { data } = await axiosClient.get(
    `/api/template-builder/library/item/${itemId}`
  );
  return data;
}

/**
 * POST /api/template-builder/library/{itemId}/activate
 * body: { languages: ["en_US"] }
 * @param {string} itemId
 * @param {{languages:string[]}} payload
 * @returns {Promise<Object>} e.g., { draftId: "..." }
 */
export async function activateLibraryItem(itemId, payload) {
  const { data } = await axiosClient.post(
    `/api/template-builder/library/${itemId}/activate`,
    payload
  );
  return data;
}

/**
 * POST /api/template-builder/library/import?dryRun=true|false
 * body: LibraryImportRequest
 * @param {Object} body
 * @param {boolean} dryRun
 */
export async function importLibrary(body, dryRun = true) {
  const { data } = await axiosClient.post(
    `/api/template-builder/library/import`,
    body,
    { params: { dryRun } }
  );
  return data;
}

/**
 * GET /api/template-builder/library/export?industry=
 * @param {string} [industry]
 */
export async function exportLibrary(industry) {
  const { data } = await axiosClient.get(
    "/api/template-builder/library/export",
    { params: { industry } }
  );
  return data;
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\templateBuilder\templates.js 
====================================================== 
 
// src/api/templateBuilder/templates.js
import axiosClient from "../../api/axiosClient";

/**
 * DELETE /api/template-builder/templates/{name}?language=
 * @param {string} name
 * @param {string} language
 */
export async function deleteApprovedTemplate(name, language = "en_US") {
  const { data } = await axiosClient.delete(
    `/api/template-builder/templates/${encodeURIComponent(name)}`,
    {
      params: { language },
    }
  );
  return data;
}

/**
 * (Optional) placeholder for list endpoint if you add it later.
 * Example: GET /api/whatsapp-templates?businessId=...
 */
export async function listApprovedTemplates(params = {}) {
  // If you don't have a backend endpoint yet, this should be implemented server-side.
  const { data } = await axiosClient.get(`/api/whatsapp-templates`, { params });
  return data;
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\api\templateBuilder\uploads.js 
====================================================== 
 
// src/api/templateBuilder/uploads.js
import axiosClient from "../../api/axiosClient";

/**
 * Upload header media (multipart/form-data)
 * POST /api/template-builder/uploads/header?mediaType=IMAGE|VIDEO|DOCUMENT
 * Form: file (IFormFile) OR sourceUrl
 * @param {File} file
 * @param {'IMAGE'|'VIDEO'|'DOCUMENT'} mediaType
 * @returns {Promise<{handle:string}>}
 */
export async function uploadHeaderMedia(file, mediaType = "IMAGE") {
  const form = new FormData();
  form.append("file", file);
  const { data } = await axiosClient.post(
    `/api/template-builder/uploads/header`,
    form,
    {
      params: { mediaType },
      headers: { "Content-Type": "multipart/form-data" },
    }
  );
  return data;
}
 
 
