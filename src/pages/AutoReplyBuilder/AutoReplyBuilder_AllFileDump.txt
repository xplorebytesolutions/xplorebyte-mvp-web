Folder and File Content Report
Root folder: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder
Generated at: 01-12-2025 10:21:21.87
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\AutoReplyBuilder.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/AutoReplyBuilder.jsx
import React, { useRef, useEffect, useState } from "react";
import { useSearchParams } from "react-router-dom";
import AutoReplyCanvas from "./components/AutoReplyCanvas";
import AutoReplySidebar from "./components/AutoReplySidebar";
import AutoReplyFlowsModal from "./components/AutoReplyFlowsListModal";
import { toast } from "react-toastify";
import axiosClient from "../../api/axiosClient";

export default function AutoReplyBuilder() {
  const canvasRef = useRef();
  const [searchParams] = useSearchParams();
  const flowId = searchParams.get("flowId");
  const [sidebarRefreshKey, setSidebarRefreshKey] = useState(0);

  // flows modal
  const [showFlowsModal, setShowFlowsModal] = useState(false);

  // üîß flow-level advanced settings (optional)
  const [matchMode, setMatchMode] = useState("Word"); // Word, Exact, StartsWith, Contains
  const [priority, setPriority] = useState(0); // higher wins when multiple flows match

  const toGuidOrNull = value =>
    typeof value === "string" && /^[0-9a-fA-F-]{36}$/.test(value)
      ? value
      : null;

  // ‚úÖ SAVE FLOW handler (connected to <AutoReplyCanvas />)
  const handleSaveFlow = async payload => {
    try {
      const nodesDto =
        payload.nodes?.map((node, idx) => {
          // Map canvas graph into AutoReplyNodeDto expected by backend
          const config = {
            ...(node.data?.config || {}),
            outgoing:
              payload.edges
                ?.filter(e => e.source === node.id)
                .map(e => ({
                  targetId:
                    payload.nodes.find(n => n.id === e.target)?.id || e.target,
                  handle: e.sourceHandle || null,
                })) || [],
          };

          return {
            // Send null for non-Guid values so backend can generate new ids
            id: toGuidOrNull(node.id),
            nodeType: node.type,
            label: node.data?.label || "",
            nodeName: node.data?.label || node.id,
            configJson: JSON.stringify(config),
            positionX: node.position?.x ?? 0,
            positionY: node.position?.y ?? 0,
            order: idx,
          };
        }) || [];

      // üîß normalize priority (fallback to 0 if invalid)
      const parsedPriority = Number(priority);
      const safePriority = Number.isNaN(parsedPriority) ? 0 : parsedPriority;

      const dto = {
        id: toGuidOrNull(payload.id) || null,
        name: payload.name?.trim() || "Untitled Flow",
        triggerKeyword: payload.triggerKeyword?.trim() || "",
        isActive: true,
        // üî• advanced matching settings (optional)
        matchMode: matchMode || "Word",
        priority: safePriority,
        nodes: nodesDto,
      };

      const { data } = await axiosClient.post("autoreplyflows", dto);
      toast.success("‚úÖ Flow saved successfully!");

      if (data?.id) {
        await loadFlowById(data.id); // reload to ensure we have the latest server copy/id
      }
      setSidebarRefreshKey(k => k + 1);
    } catch (err) {
      toast.error("‚ùå Failed to save flow");
      console.error("Save error:", err);
    }
  };

  const handleFlowDeleted = () => {
    canvasRef.current?.clearFlow?.();
    // üîÑ reset advanced settings to defaults when flow is cleared
    setMatchMode("Word");
    setPriority(0);
    setSidebarRefreshKey(k => k + 1);
  };

  const loadFlowById = async id => {
    if (!id) return;
    try {
      const { data } = await axiosClient.get(`autoreplyflows/${id}`);

      // üî• apply advanced settings from backend (with smart defaults)
      const incomingMode = data?.matchMode;
      const safeMode =
        typeof incomingMode === "string" && incomingMode.trim().length > 0
          ? incomingMode
          : "Word";

      const incomingPriority = data?.priority;
      const safeIncomingPriority =
        typeof incomingPriority === "number" && !Number.isNaN(incomingPriority)
          ? incomingPriority
          : 0;

      setMatchMode(safeMode);
      setPriority(safeIncomingPriority);

      // keep existing behaviour for canvas
      canvasRef.current?.loadFlow(data);
      toast.success("‚úÖ Flow loaded");
    } catch (err) {
      toast.error("‚ùå Error loading flow");
      console.error(err);
    }
  };

  useEffect(() => {
    if (flowId) {
      loadFlowById(flowId);
    }
  }, [flowId]);

  return (
    <div className="flex h-screen overflow-hidden bg-gray-50">
      {/* Sidebar (left) */}
      <div className="w-72 border-r border-gray-200 bg-white p-4">
        <h2 className="text-lg font-semibold mb-4 text-zinc-800">
          üß† Auto-Reply Blocks
        </h2>
        <AutoReplySidebar
          key={sidebarRefreshKey}
          onSelectFlow={loadFlowById}
          onDeleteFlow={handleFlowDeleted}
        />
      </div>

      {/* Main Area (right) */}
      <div className="flex-1 flex flex-col">
        {/* Canvas + Settings */}
        <div className="flex-1 bg-white relative overflow-auto">
          <AutoReplyCanvas
            ref={canvasRef}
            flowName=""
            triggerKeywords=""
            onSave={handleSaveFlow}
            // üîó let the canvas header "Flows" button open the modal
            onOpenFlows={() => setShowFlowsModal(true)}
          />

          {/* üîß Flow-level advanced settings (optional) */}
        </div>
      </div>

      {/* Flows Modal */}
      <AutoReplyFlowsModal
        open={showFlowsModal}
        onClose={() => setShowFlowsModal(false)}
        onFlowSelected={flowIdOrFlow => {
          // You were passing `flow.id` earlier; now we support both id or object.
          const id =
            typeof flowIdOrFlow === "string"
              ? flowIdOrFlow
              : flowIdOrFlow?.id ?? null;
          if (id) {
            loadFlowById(id);
          }
        }}
      />
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\MakeDump.bat 
====================================================== 
 
@echo off
REM This script will find relevant source files and output their names and contents into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh and write a small header
> "%outputFile%" (
    echo Folder and File Content Report
    echo Root folder: %cd%
    echo Generated at: %date% %time%
)
echo. >> "%outputFile%"

REM NOTE:
REM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)
REM This keeps the file smaller and much easier to review.

REM Loop through all relevant files in the current directory and subdirectories
REM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML
for /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (

    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)
    echo "%%F" | findstr /I /C:"\node_modules\" /C:"\bin\" /C:"\obj\" /C:"\.git\" /C:"\dist\" /C:"\.vs\" >nul
    if errorlevel 1 (
        echo ====================================================== >> "%outputFile%"
        echo FILE: %%F >> "%outputFile%"
        echo ====================================================== >> "%outputFile%"
        echo. >> "%outputFile%"
        type "%%F" >> "%outputFile%" 2>nul
        echo. >> "%outputFile%"
        echo. >> "%outputFile%"
    )
)

echo Finished! All content has been extracted to %outputFile%
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplyCanvas.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplyCanvas.jsx
import React, {
  useCallback,
  useState,
  useRef,
  forwardRef,
  useImperativeHandle,
  useEffect,
} from "react";
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  addEdge,
  useNodesState,
  useEdgesState,
  ReactFlowProvider,
} from "reactflow";
import "reactflow/dist/style.css";

import { toast } from "react-toastify";
import { Button } from "../../../components/ui/button";
import { Settings } from "lucide-react";
import AutoReplyNodeStart from "./AutoReplyNodeStart";
import AutoReplyNodeBlock from "./AutoReplyNodeBlock";
import AutoReplyNodeEditor from "./AutoReplyNodeEditor";

const nodeTypes = {
  start: AutoReplyNodeStart,
  message: AutoReplyNodeBlock,
  template: AutoReplyNodeBlock,
  wait: AutoReplyNodeBlock,
  tag: AutoReplyNodeBlock,
  cta_flow: AutoReplyNodeBlock, // üÜï CTA Flow nodes use the same block renderer
};

let id = 1;
const getId = () => `node_${id++}`;

const AutoReplyCanvas = forwardRef((props, ref) => {
  const reactFlowWrapper = useRef(null);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);

  const [currentFlowId, setCurrentFlowId] = useState(null);
  const [flowName, setFlowName] = useState("");
  const [triggerKeywords, setTriggerKeywords] = useState("");

  const [nodes, setNodes, onNodesChange] = useNodesState([
    {
      id: "start-1",
      type: "start",
      position: { x: 100, y: 100 },
      data: { label: "start" },
    },
  ]);

  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedNode, setSelectedNode] = useState(null);
  const [pendingDeleteId, setPendingDeleteId] = useState(null);

  // üîÑ tracking for ‚Äúunsaved changes‚Äù
  const [lastSavedSnapshot, setLastSavedSnapshot] = useState(null);
  const [isDirty, setIsDirty] = useState(false);

  // üîß NEW: advanced settings popover visibility
  const [showAdvanced, setShowAdvanced] = useState(false);

  // easy access to advanced props from parent
  const {
    onOpenFlows,
    onSave,
    flowName: initialFlowName,
    triggerKeywords: initialTriggerKeywords,
    matchMode,
    priority,
    onMatchModeChange,
    onPriorityChange,
  } = props;

  // --------------------------------------------------
  // snapshot helpers ‚Äì used for dirty-state tracking
  // --------------------------------------------------
  const computeSnapshot = (
    nodesArg,
    edgesArg,
    flowNameArg,
    triggerKeywordsArg,
    flowIdArg
  ) => {
    const simpleNodes = (nodesArg || []).map(n => ({
      id: n.id,
      type: n.type,
      x: n.position?.x ?? 0,
      y: n.position?.y ?? 0,
      label: n.data?.label || "",
    }));

    const simpleEdges = (edgesArg || []).map(e => ({
      id: e.id,
      source: e.source,
      target: e.target,
      sourceHandle: e.sourceHandle || null,
      targetHandle: e.targetHandle || null,
    }));

    return JSON.stringify({
      id: flowIdArg ?? null,
      name: flowNameArg || "",
      triggerKeyword: triggerKeywordsArg || "",
      nodes: simpleNodes,
      edges: simpleEdges,
    });
  };

  // recompute dirty flag whenever graph or meta changes
  useEffect(() => {
    if (!lastSavedSnapshot) {
      // no baseline yet (initial load / brand new flow)
      return;
    }

    const snap = computeSnapshot(
      nodes,
      edges,
      flowName,
      triggerKeywords,
      currentFlowId
    );
    setIsDirty(snap !== lastSavedSnapshot);
  }, [
    nodes,
    edges,
    flowName,
    triggerKeywords,
    currentFlowId,
    lastSavedSnapshot,
  ]);

  // --------------------------------------------------
  // deletion helpers
  // --------------------------------------------------
  const handleDeleteNode = useCallback(
    nodeId => {
      setNodes(nds => nds.filter(n => n.id !== nodeId));
      setEdges(eds =>
        eds.filter(e => e.source !== nodeId && e.target !== nodeId)
      );
      setSelectedNode(null);
    },
    [setNodes, setEdges]
  );

  const confirmDeleteNode = useCallback(
    nodeId => {
      const node = nodes.find(n => n.id === nodeId);
      if (node?.type === "start") {
        setPendingDeleteId(nodeId);
      } else {
        handleDeleteNode(nodeId);
      }
    },
    [nodes, handleDeleteNode]
  );

  // --------------------------------------------------
  // ReactFlow callbacks
  // --------------------------------------------------
  const onConnect = useCallback(
    params => {
      const customId = `reactflow__edge-${params.source}${
        params.sourceHandle ? params.sourceHandle : ""
      }-${params.target}`;
      setEdges(eds =>
        addEdge(
          {
            ...params,
            id: customId,
            type: "smoothstep",
          },
          eds
        )
      );
    },
    [setEdges]
  );

  const onEdgeClick = useCallback(
    (event, edge) => {
      event.stopPropagation();
      setEdges(eds => eds.filter(e => e.id !== edge.id));
    },
    [setEdges]
  );

  const onDrop = useCallback(
    event => {
      event.preventDefault();
      const type = event.dataTransfer.getData("application/reactflow");
      if (!type || !reactFlowInstance) return;

      const bounds = reactFlowWrapper.current.getBoundingClientRect();
      const position = reactFlowInstance.project({
        x: event.clientX - bounds.left,
        y: event.clientY - bounds.top,
      });

      const newId = getId();
      const newNode = {
        id: newId,
        type,
        position,
        data: {
          id: newId,
          label: type,
          config: {},
          onDelete: confirmDeleteNode,
        },
      };

      setNodes(nds => nds.concat(newNode));
    },
    [reactFlowInstance, confirmDeleteNode, setNodes]
  );

  const onDragOver = useCallback(event => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
  }, []);

  const onNodeClick = useCallback((_, node) => {
    setSelectedNode(node);
  }, []);

  const handleNodeSave = updatedNode => {
    setNodes(prev =>
      prev.map(n => (n.id === updatedNode.id ? updatedNode : n))
    );
    setSelectedNode(null);
  };

  // --------------------------------------------------
  // SAVE FLOW ‚Äì builds DTO payload and delegates up
  // --------------------------------------------------
  const handleSaveFlow = async () => {
    if (!reactFlowInstance) return;

    const flow = reactFlowInstance.toObject();
    const nodeMap = {};
    flow.nodes.forEach(node => {
      nodeMap[node.id] = node.data?.id || node.id;
    });

    const processedEdges =
      flow.edges?.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        sourceNodeId: nodeMap[edge.source],
        targetNodeId: nodeMap[edge.target],
        sourceHandle: edge.sourceHandle ?? null,
        targetHandle: edge.targetHandle ?? null,
      })) || [];

    const processedNodes =
      flow.nodes?.map(node => {
        const id = node.data?.id || node.id;
        const nodeConfig =
          typeof node.data?.config === "object"
            ? JSON.parse(JSON.stringify(node.data.config))
            : {};

        return {
          id,
          type: node.type,
          position: { x: node.position.x, y: node.position.y },
          data: {
            label: node.data?.label || "",
            config: nodeConfig,
          },
        };
      }) || [];

    const payload = {
      id: currentFlowId,
      name: flowName.trim() || initialFlowName || "Untitled Flow",
      triggerKeyword: triggerKeywords.trim() || initialTriggerKeywords || "",
      nodes: processedNodes,
      edges: processedEdges,
    };

    if (typeof onSave === "function") {
      await onSave(payload);

      // update baseline snapshot on successful save
      const savedSnapshot = computeSnapshot(
        processedNodes,
        processedEdges,
        payload.name,
        payload.triggerKeyword,
        currentFlowId
      );
      setLastSavedSnapshot(savedSnapshot);
      setIsDirty(false);
      return;
    }

    toast.error("‚ùå Save function is not connected.");
  };

  // --------------------------------------------------
  // expose helpers to parent via ref
  // --------------------------------------------------
  useImperativeHandle(ref, () => ({
    loadFlow: flowData => {
      setCurrentFlowId(flowData?.id ?? null);
      setFlowName(flowData?.name || "");
      setTriggerKeywords(flowData?.triggerKeyword || flowData?.keyword || "");

      const loadedNodes =
        flowData?.nodes?.map(node => {
          const config =
            typeof node.configJson === "string"
              ? JSON.parse(node.configJson || "{}")
              : node.configJson || {};
          return {
            id: node.id,
            type: node.nodeType,
            position: { x: node.positionX ?? 0, y: node.positionY ?? 0 },
            data: {
              id: node.id,
              label: node.label || node.nodeName || node.nodeType,
              config,
            },
          };
        }) || [];

      const loadedEdges = [];
      loadedNodes.forEach(node => {
        const outgoing = node.data?.config?.outgoing || [];
        outgoing.forEach((edgeCfg, idx) => {
          loadedEdges.push({
            id: `${node.id}->${edgeCfg.targetId}-${idx}`,
            source: node.id,
            target: edgeCfg.targetId,
            sourceHandle: edgeCfg.handle || null,
          });
        });
      });

      const nextNodes =
        loadedNodes.length > 0
          ? loadedNodes
          : [
              {
                id: "start-1",
                type: "start",
                position: { x: 100, y: 100 },
                data: { label: "start" },
              },
            ];

      setNodes(nextNodes);
      setEdges(loadedEdges);

      // establish clean baseline for dirty tracking
      const baselineSnapshot = computeSnapshot(
        nextNodes,
        loadedEdges,
        flowData?.name || "",
        flowData?.triggerKeyword || flowData?.keyword || "",
        flowData?.id ?? null
      );
      setLastSavedSnapshot(baselineSnapshot);
      setIsDirty(false);
    },
    handleSaveFlow,
    saveFlow: handleSaveFlow,
    clearFlow: () => {
      setCurrentFlowId(null);
      setFlowName("");
      setTriggerKeywords("");

      const defaultNodes = [
        {
          id: "start-1",
          type: "start",
          position: { x: 100, y: 100 },
          data: { label: "start" },
        },
      ];

      setNodes(defaultNodes);
      setEdges([]);

      const baselineSnapshot = computeSnapshot(defaultNodes, [], "", "", null);
      setLastSavedSnapshot(baselineSnapshot);
      setIsDirty(false);
    },
  }));

  // --------------------------------------------------
  // RENDER
  // --------------------------------------------------
  return (
    <ReactFlowProvider>
      {/* Compact header with inputs + buttons in one row */}
      <div className="px-4 py-3 bg-white border-b border-gray-200">
        <div className="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
          {/* Flow name + triggers */}
          <div className="flex-1 flex flex-col md:flex-row md:gap-4">
            <div className="flex-1 mb-2 md:mb-0">
              <label className="block text-xs font-medium text-zinc-700 mb-1">
                Flow name
              </label>
              <input
                type="text"
                value={flowName}
                onChange={e => setFlowName(e.target.value)}
                placeholder="e.g. Welcome Flow"
                className="w-full border border-slate-200 rounded-md px-2 py-1.5 text-sm"
              />
            </div>

            {/* Trigger + settings */}
            <div className="flex-1 relative">
              <label className="block text-xs font-medium text-zinc-700 mb-1">
                Trigger keywords (comma separated)
              </label>
              <div className="flex items-center gap-2">
                <input
                  type="text"
                  value={triggerKeywords}
                  onChange={e => setTriggerKeywords(e.target.value)}
                  placeholder="hi, hello, hey"
                  className="flex-1 border border-slate-200 rounded-md px-2 py-1.5 text-sm"
                />

                {/* ‚öô Advanced settings button (emerald) */}
                <button
                  type="button"
                  onClick={() => setShowAdvanced(prev => !prev)}
                  className={`inline-flex items-center justify-center h-8 w-8 rounded-md border text-xs font-medium transition-colors ${
                    showAdvanced
                      ? "bg-emerald-600 text-white border-emerald-600"
                      : "bg-white text-emerald-700 border-emerald-300 hover:bg-emerald-50"
                  }`}
                  title="Flow matching settings"
                >
                  <Settings className="w-4 h-4" />
                </button>
              </div>

              {/* Advanced settings popover */}
              {showAdvanced && (
                <div className="absolute right-0 mt-2 z-30 w-72 bg-white border border-slate-200 rounded-lg shadow-lg p-3">
                  <h4 className="text-xs font-semibold text-slate-800 mb-2">
                    Flow Settings (Advanced)
                  </h4>

                  {/* Match mode */}
                  <div className="mb-3">
                    <label className="block text-[11px] font-medium text-slate-600 mb-1">
                      Match mode
                    </label>
                    <select
                      className="w-full px-2 py-1.5 rounded-md border border-slate-300 text-xs bg-white"
                      value={matchMode || "Word"}
                      onChange={e =>
                        onMatchModeChange?.(e.target.value || "Word")
                      }
                    >
                      <option value="Word">Word (default)</option>
                      <option value="Exact">Exact</option>
                      <option value="StartsWith">StartsWith</option>
                      <option value="Contains">Contains</option>
                    </select>
                    <p className="mt-1 text-[10px] text-slate-500">
                      Controls how trigger keywords are matched against incoming
                      messages. If you‚Äôre not sure, keep it on <b>Word</b>.
                    </p>
                  </div>

                  {/* Priority */}
                  <div className="mb-2">
                    <label className="block text-[11px] font-medium text-slate-600 mb-1">
                      Priority
                    </label>
                    <input
                      type="number"
                      min={0}
                      max={100}
                      className="w-full px-2 py-1.5 rounded-md border border-slate-300 text-xs"
                      value={priority}
                      onChange={e => onPriorityChange?.(e.target.value)}
                    />
                    <p className="mt-1 text-[10px] text-slate-500">
                      Higher priority wins when multiple flows match the same
                      message. Leave <b>0</b> if you‚Äôre not sure.
                    </p>
                  </div>

                  {/* Reset / Close row */}
                  <div className="flex items-center justify-between mt-2">
                    <button
                      type="button"
                      className="text-[11px] text-slate-500 hover:text-slate-700"
                      onClick={() => {
                        onMatchModeChange?.("Word");
                        onPriorityChange?.(0);
                      }}
                    >
                      Reset to defaults
                    </button>
                    <button
                      type="button"
                      className="text-[11px] text-emerald-700 font-medium"
                      onClick={() => setShowAdvanced(false)}
                    >
                      Done
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Actions ‚Äì Flows + Save */}
          <div className="flex items-center gap-2 md:ml-4">
            {/* Flow list button ‚Äì emerald */}
            <Button
              type="button"
              size="sm"
              onClick={onOpenFlows}
              className="h-8 px-3 text-xs font-semibold bg-emerald-600 text-white hover:bg-emerald-700 shadow-sm"
            >
              <span className="mr-1 text-[11px]">‚ò∞</span>
              Flows
            </Button>

            {/* Save flow button ‚Äì emerald */}
            <Button
              type="button"
              size="sm"
              onClick={handleSaveFlow}
              className="h-8 px-3 text-xs font-semibold bg-emerald-600 text-white hover:bg-emerald-700 shadow-sm"
            >
              üíæ Save Flow
            </Button>
          </div>
        </div>
      </div>

      <div
        ref={reactFlowWrapper}
        className="w-full h-[calc(100vh-10rem)]"
        onDrop={onDrop}
        onDragOver={onDragOver}
      >
        <ReactFlow
          nodes={nodes.map(n => ({
            ...n,
            data: { ...n.data, onDelete: confirmDeleteNode },
          }))}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onEdgeClick={onEdgeClick}
          onNodeClick={onNodeClick}
          onInit={setReactFlowInstance}
          fitView
          nodeTypes={nodeTypes}
        >
          <Background />
          <MiniMap />
          <Controls />
        </ReactFlow>

        <AutoReplyNodeEditor
          node={selectedNode}
          onClose={() => setSelectedNode(null)}
          onSave={handleNodeSave}
        />

        {pendingDeleteId && (
          <div className="fixed inset-0 bg-black/30 z-50 flex items-center justify-center">
            <div className="bg-white p-6 rounded shadow-xl max-w-sm w-full">
              <h2 className="text-lg font-bold text-red-600 mb-2">
                Delete Start Block?
              </h2>
              <p className="text-sm text-gray-600 mb-4">
                This is the starting point of the flow. Deleting it may break
                connected logic.
              </p>
              <div className="flex justify-end gap-2">
                <button
                  className="text-sm px-3 py-1 rounded bg-gray-200"
                  onClick={() => setPendingDeleteId(null)}
                >
                  Cancel
                </button>
                <button
                  className="text-sm px-3 py-1 rounded bg-red-600 text-white"
                  onClick={() => {
                    handleDeleteNode(pendingDeleteId);
                    setPendingDeleteId(null);
                  }}
                >
                  Delete
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </ReactFlowProvider>
  );
});

export default AutoReplyCanvas;
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplyFlowsListModal.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplyFlowsListModal.jsx
import React, { useEffect, useState } from "react";
import axiosClient from "../../../api/axiosClient";
import { X, RefreshCcw, FlaskConical } from "lucide-react";
import { toast } from "react-toastify";
import { useAuth } from "../../../app/providers/AuthProvider";

function formatDate(value) {
  if (!value) return "-";
  try {
    return new Date(value).toLocaleString();
  } catch {
    return value;
  }
}

export default function AutoReplyFlowsListModal({
  open,
  onClose,
  onFlowSelected,
}) {
  const [flows, setFlows] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // üîê get business id for test-match
  const { business } = useAuth() || {};
  const businessId = business?.id;

  // üî¨ test-match modal state
  const [testOpen, setTestOpen] = useState(false);
  const [testFlow, setTestFlow] = useState(null);
  const [testText, setTestText] = useState("");
  const [testResult, setTestResult] = useState(null);
  const [testLoading, setTestLoading] = useState(false);
  const [testError, setTestError] = useState(null);

  // load flows when modal opens
  useEffect(() => {
    if (!open) return;

    const load = async () => {
      setLoading(true);
      setError(null);
      try {
        const { data } = await axiosClient.get("autoreplyflows");
        setFlows(Array.isArray(data) ? data : []);
      } catch (err) {
        console.error("Failed to load flows list", err);
        setError(
          err?.response?.data?.message ||
            err?.message ||
            "Unable to load flows."
        );
      } finally {
        setLoading(false);
      }
    };

    load();
  }, [open]);

  // toggle active / inactive status for a single flow
  const handleToggleStatus = async (flow, evt) => {
    // prevent the row click (which opens the flow) from firing
    if (evt) {
      evt.stopPropagation();
      evt.preventDefault();
    }

    const next = !flow.isActive;

    try {
      await axiosClient.patch(`autoreplyflows/${flow.id}/status`, {
        isActive: next,
      });

      // update local state
      setFlows(prev =>
        prev.map(f =>
          f.id === flow.id
            ? {
                ...f,
                isActive: next,
                // bump updatedAt so UI shows something fresh
                updatedAt: new Date().toISOString(),
              }
            : f
        )
      );

      toast.success(
        next ? "Flow activated successfully." : "Flow deactivated successfully."
      );
    } catch (err) {
      console.error("Failed to toggle flow status", err);
      toast.error("Failed to update flow status. Please try again.");
    }
  };

  // üî¨ open test modal for a given flow
  const openTestForFlow = (flow, evt) => {
    if (evt) {
      evt.stopPropagation();
      evt.preventDefault();
    }

    setTestFlow(flow);
    setTestResult(null);
    setTestError(null);

    // prefill example text with first trigger keyword (if any)
    const raw = flow.triggerKeyword || "";
    const firstKeyword =
      raw
        .split(/[,|\n|\r]/)
        .map(x => x.trim())
        .filter(Boolean)[0] || "";
    setTestText(firstKeyword);

    setTestOpen(true);
  };

  const closeTestModal = () => {
    setTestOpen(false);
    setTestFlow(null);
    setTestText("");
    setTestResult(null);
    setTestError(null);
    setTestLoading(false);
  };

  const handleRunTest = async () => {
    if (!testText.trim()) return;

    if (!businessId) {
      setTestError("Missing business id in auth context.");
      return;
    }

    setTestLoading(true);
    setTestError(null);
    setTestResult(null);

    try {
      const payload = {
        businessId,
        incomingText: testText.trim(),
      };

      const res = await axiosClient.post("autoreplyflows/test-match", payload);
      setTestResult(res?.data || null);
    } catch (err) {
      console.error("Test-match error (flows modal)", err);
      setTestError(
        err?.response?.data?.message ||
          err?.message ||
          "Failed to test auto-reply match."
      );
    } finally {
      setTestLoading(false);
    }
  };

  if (!open) return null;

  const isThisFlowSelected =
    testResult &&
    testResult.isMatch &&
    testFlow &&
    testResult.flowId === testFlow.id;

  return (
    <div className="fixed inset-0 z-[999] flex items-center justify-center bg-black/40 backdrop-blur-sm">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[80vh] flex flex-col overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-5 py-3 border-b bg-gradient-to-r from-emerald-50 via-teal-50 to-emerald-50">
          <div>
            <h2 className="text-base font-semibold text-emerald-900">
              Auto-Reply Flows
            </h2>
            <p className="text-xs text-emerald-700">
              Click a row to open the flow on the canvas. Use the toggle to
              activate or deactivate a flow. Use{" "}
              <span className="font-semibold">Test</span> to see which flow
              would trigger for a sample message.
            </p>
          </div>
          <button
            type="button"
            onClick={onClose}
            className="inline-flex items-center justify-center rounded-full p-1.5 hover:bg-emerald-100"
          >
            <X className="w-4 h-4 text-emerald-700" />
          </button>
        </div>

        {/* Body */}
        <div className="flex-1 overflow-auto bg-white">
          {loading && (
            <div className="p-4 text-sm text-zinc-600 flex items-center gap-2">
              <RefreshCcw className="w-4 h-4 animate-spin" />
              Loading flows...
            </div>
          )}

          {error && !loading && (
            <div className="p-4 text-sm text-red-600">{error}</div>
          )}

          {!loading && !error && flows.length === 0 && (
            <div className="p-4 text-sm text-zinc-500">
              No flows found yet. Create your first auto-reply flow from the
              canvas.
            </div>
          )}

          {!loading && !error && flows.length > 0 && (
            <table className="w-full text-sm">
              <thead className="bg-zinc-50 border-b">
                <tr>
                  <th className="text-left py-2 px-4 font-medium text-xs text-zinc-500">
                    Name
                  </th>
                  <th className="text-left py-2 px-4 font-medium text-xs text-zinc-500">
                    Trigger Keywords
                  </th>
                  <th className="text-left py-2 px-4 font-medium text-xs text-zinc-500">
                    Status
                  </th>
                  <th className="text-left py-2 px-4 font-medium text-xs text-zinc-500">
                    Created
                  </th>
                  <th className="text-left py-2 px-4 font-medium text-xs text-zinc-500">
                    Updated
                  </th>
                  <th className="text-left py-2 px-4 font-medium text-xs text-zinc-500">
                    Test
                  </th>
                  <th className="text-right py-2 px-4 font-medium text-xs text-zinc-500">
                    Toggle
                  </th>
                </tr>
              </thead>
              <tbody>
                {flows.map(flow => {
                  const active = flow.isActive;
                  return (
                    <tr
                      key={flow.id}
                      className="border-b last:border-b-0 hover:bg-zinc-50 cursor-pointer"
                      onClick={() => {
                        if (typeof onFlowSelected === "function") {
                          onFlowSelected(flow.id);
                        }
                        onClose?.();
                      }}
                    >
                      <td className="py-2 px-4">
                        <div className="font-medium text-zinc-800">
                          {flow.name}
                        </div>
                      </td>
                      <td className="py-2 px-4">
                        <div className="text-xs text-zinc-600 truncate max-w-xs">
                          {flow.triggerKeyword || "-"}
                        </div>
                      </td>
                      <td className="py-2 px-4">
                        <span
                          className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-[11px] font-medium ${
                            active
                              ? "bg-emerald-50 text-emerald-700 border border-emerald-100"
                              : "bg-zinc-100 text-zinc-600 border border-zinc-200"
                          }`}
                        >
                          <span
                            className={`w-1.5 h-1.5 rounded-full mr-1.5 ${
                              active ? "bg-emerald-500" : "bg-zinc-400"
                            }`}
                          ></span>
                          {active ? "Active" : "Inactive"}
                        </span>
                      </td>
                      <td className="py-2 px-4 text-xs text-zinc-600">
                        {formatDate(flow.createdAt)}
                      </td>
                      <td className="py-2 px-4 text-xs text-zinc-600">
                        {formatDate(flow.updatedAt)}
                      </td>

                      {/* Test button */}
                      <td className="py-2 px-4">
                        <button
                          type="button"
                          onClick={evt => openTestForFlow(flow, evt)}
                          className="inline-flex items-center gap-1 px-2 py-1 rounded-md border border-emerald-200 text-[11px] text-emerald-700 hover:bg-emerald-50 hover:border-emerald-400 transition-colors"
                        >
                          <FlaskConical className="w-3 h-3" />
                          Test
                        </button>
                      </td>

                      {/* Toggle */}
                      <td className="py-2 px-4 text-right">
                        <button
                          type="button"
                          onClick={evt => handleToggleStatus(flow, evt)}
                          className={`relative inline-flex h-5 w-9 cursor-pointer items-center rounded-full border transition-colors duration-200 ${
                            active
                              ? "bg-emerald-500 border-emerald-500"
                              : "bg-zinc-300 border-zinc-300"
                          }`}
                        >
                          <span
                            className={`h-4 w-4 rounded-full bg-white shadow transform transition-transform duration-200 ${
                              active ? "translate-x-4" : "translate-x-0"
                            }`}
                          />
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          )}
        </div>

        {/* Footer */}
        <div className="px-5 py-3 border-t bg-white flex justify-end">
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-1.5 text-sm rounded-lg border border-zinc-300 text-zinc-700 hover:bg-zinc-50"
          >
            Close
          </button>
        </div>
      </div>

      {/* üî¨ Test Auto-Reply Match modal (on top of flows modal) */}
      {testOpen && (
        <div className="fixed inset-0 z-[1000] flex items-center justify-center bg-black/20">
          <div className="bg-white rounded-xl shadow-xl w-full max-w-md p-4">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-sm font-semibold text-slate-800">
                Test Auto-Reply Match
              </h3>
              <button
                type="button"
                onClick={closeTestModal}
                className="p-1 rounded-full hover:bg-slate-100"
              >
                <X className="w-4 h-4 text-slate-600" />
              </button>
            </div>

            <p className="text-xs text-slate-600 mb-3">
              Flow:{" "}
              <span className="font-semibold">
                {testFlow?.name || testFlow?.id || "-"}
              </span>
            </p>

            <div className="mb-2">
              <label className="block text-xs font-medium text-slate-600 mb-1">
                Sample incoming message
              </label>
              <input
                type="text"
                className="w-full px-3 py-2 rounded-lg border border-slate-300 text-sm"
                placeholder="Type what the customer might send..."
                value={testText}
                onChange={e => setTestText(e.target.value)}
              />
            </div>

            <div className="flex justify-end mb-2">
              <button
                type="button"
                onClick={handleRunTest}
                disabled={testLoading || !testText.trim()}
                className="inline-flex items-center gap-1 px-3 py-1.5 text-sm rounded-lg bg-emerald-600 text-white disabled:opacity-50"
              >
                <FlaskConical className="w-4 h-4" />
                {testLoading ? "Testing..." : "Run test"}
              </button>
            </div>

            {testError && (
              <p className="text-xs text-red-600 mb-2">{testError}</p>
            )}

            {testResult && (
              <div className="mt-2 text-xs text-slate-700 space-y-1 border-t border-slate-100 pt-2">
                <p>
                  <span className="font-semibold">Matched:</span>{" "}
                  {testResult.isMatch ? "Yes" : "No"}
                </p>

                {testResult.isMatch && (
                  <>
                    <p>
                      <span className="font-semibold">Matched flow:</span>{" "}
                      {testResult.flowName || testResult.flowId}
                    </p>
                    <p>
                      <span className="font-semibold">Is this flow?</span>{" "}
                      {isThisFlowSelected ? (
                        <span className="text-emerald-700 font-semibold">
                          Yes, this flow will trigger.
                        </span>
                      ) : (
                        <span className="text-amber-700">
                          No, a different flow has higher priority or a better
                          match.
                        </span>
                      )}
                    </p>
                    <p>
                      <span className="font-semibold">Keyword:</span>{" "}
                      {testResult.matchedKeyword || "-"}
                    </p>
                    <p>
                      <span className="font-semibold">Start node:</span>{" "}
                      {testResult.startNodeType || "?"} /{" "}
                      {testResult.startNodeName || "-"}
                    </p>
                  </>
                )}

                {!testResult.isMatch && (
                  <p className="text-amber-700">
                    No auto-reply flow matched this message.
                  </p>
                )}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplyLogsPanel.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplyLogsPanel.jsx
import React, { useEffect, useState, useCallback } from "react";
import axiosClient from "../../../api/axiosClient";

export default function AutoReplyLogsPanel({ businessId }) {
  const [logs, setLogs] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchLogs = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      // backend will infer BusinessId from JWT claims
      const res = await axiosClient.get("autoreplylogs/recent", {
        params: { take: 20 },
      });
      setLogs(res?.data || []);
    } catch (err) {
      console.error("Failed to load auto-reply logs", err);
      const status = err?.response?.status;
      if (status === 404) {
        setError(
          "Logs endpoint not available yet (404). Backend wiring still pending."
        );
      } else {
        setError(
          err?.response?.data?.message ||
            err?.message ||
            "Failed to load auto-reply logs."
        );
      }
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    // only attempt if we have a business context
    if (businessId) {
      fetchLogs();
    }
  }, [businessId, fetchLogs]);

  return (
    <div className="mt-4 p-4 bg-white rounded-xl shadow-sm border border-slate-200 mx-4 mb-8">
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-sm font-semibold text-slate-800">
          Recent Auto-Reply Logs
        </h3>
        <button
          type="button"
          onClick={fetchLogs}
          disabled={loading}
          className="text-xs px-2 py-1 rounded border border-slate-300 text-slate-700 hover:bg-slate-50 disabled:opacity-50"
        >
          {loading ? "Refreshing..." : "Refresh"}
        </button>
      </div>

      {error && (
        <p className="text-xs text-red-600 mb-2 whitespace-pre-line">{error}</p>
      )}

      {!error && !loading && logs.length === 0 && (
        <p className="text-xs text-slate-500">
          No auto-reply logs yet. Try sending a test message that triggers a
          flow.
        </p>
      )}

      {!error && logs.length > 0 && (
        <div className="mt-2 max-h-64 overflow-auto">
          <table className="w-full text-xs text-left">
            <thead className="text-slate-500 border-b">
              <tr>
                <th className="py-1 pr-2">Time</th>
                <th className="py-1 pr-2">Flow</th>
                <th className="py-1 pr-2">Keyword</th>
                <th className="py-1 pr-2">Reply Preview</th>
              </tr>
            </thead>
            <tbody>
              {logs.map(log => (
                <tr key={log.id} className="border-b last:border-b-0">
                  <td className="py-1 pr-2 align-top text-slate-600">
                    {log.triggeredAt
                      ? new Date(log.triggeredAt).toLocaleString()
                      : "-"}
                  </td>
                  <td className="py-1 pr-2 align-top font-medium text-slate-800">
                    {log.flowName || "‚Äî"}
                  </td>
                  <td className="py-1 pr-2 align-top text-slate-700">
                    {log.triggerKeyword || "‚Äî"}
                  </td>
                  <td className="py-1 pr-2 align-top text-slate-600">
                    {log.replyContent
                      ? log.replyContent.length > 60
                        ? log.replyContent.slice(0, 60) + "‚Ä¶"
                        : log.replyContent
                      : "‚Äî"}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplyNodeBlock.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplyNodeBlock.jsx
import React from "react";
import { Handle, Position } from "reactflow";

// Helper: show "Step 1" instead of "node_1" etc.
function formatStepLabel(rawId) {
  if (!rawId) return "Unnamed";
  const match = /^node_(\d+)$/i.exec(rawId);
  if (match) {
    return `Step ${match[1]}`;
  }
  return rawId;
}

export default function AutoReplyNodeBlock({ data }) {
  const type = data.label; // e.g. "message", "template", "cta_flow"
  const config = data?.config || {};

  const labelMap = {
    message: "üí¨ Message",
    template: "üìÑ Template",
    wait: "‚è± Wait",
    tag: "üè∑ Tag",
    cta_flow: "üîÄ CTA Flow", // üÜï CTA Flow node label
  };

  const bgColorMap = {
    message: "border-blue-300 bg-blue-50",
    template: "border-purple-300 bg-purple-50",
    wait: "border-yellow-300 bg-yellow-50",
    tag: "border-pink-300 bg-pink-50",
    cta_flow: "border-emerald-300 bg-emerald-50", // üÜï CTA Flow color
  };

  const blockLabel = labelMap[type] || "üß© Block";
  const blockStyle = bgColorMap[type] || "border-gray-300 bg-gray-50";

  const body = config.body || config.text || "";
  const buttons = Array.isArray(config.multiButtons) ? config.multiButtons : [];

  // üÜï CTA flow name, saved from the node editor
  const ctaFlowName = config.ctaFlowName || "";

  return (
    <div
      className={`relative group rounded-md border px-2 py-1.5 min-h-[70px] w-[220px] max-w-[220px] text-[7px] text-zinc-800 transition-all duration-200 ${blockStyle} hover:shadow-md hover:scale-[1.02]`}
    >
      {type !== "start" && (
        <Handle
          type="target"
          position={Position.Top}
          style={{ background: "#ccc" }}
        />
      )}
      <Handle
        type="source"
        position={Position.Bottom}
        style={{ background: "#ccc" }}
      />

      {/* Delete button */}
      {data?.onDelete && (
        <button
          onClick={e => {
            e.stopPropagation();
            data.onDelete(data.id);
          }}
          className="absolute top-1 right-1.5 text-[7px] text-red-500 hover:text-red-700 opacity-0 group-hover:opacity-100 transition"
          title="Delete this block"
        >
          ‚úï
        </button>
      )}

      {/* Header */}
      <div className="font-semibold text-[8px] leading-tight mb-0.5">
        {blockLabel}
      </div>

      {/* Step label */}
      <div className="text-[7px] text-purple-600 font-medium mb-0.5">
        {formatStepLabel(data.id)}
      </div>

      {/* üÜï CTA Flow info */}
      {type === "cta_flow" && (
        <div className="mt-0.5 text-[7px] text-emerald-700">
          Flow:{" "}
          <span className="font-semibold">
            {ctaFlowName || "No CTA flow selected"}
          </span>
        </div>
      )}

      {/* Body ‚Äì compact preview with thin scroll (for message/template) */}
      {body && type !== "cta_flow" && (
        <div className="ar-node-body-scroll text-[7px] text-zinc-700 whitespace-pre-wrap max-h-14 overflow-y-auto pr-1">
          {body}
        </div>
      )}

      {/* Template buttons */}
      {type === "template" && buttons.length > 0 && (
        <div className="mt-0.5 flex flex-col gap-0.5">
          {buttons.map((btn, index) => (
            <div
              key={index}
              className="relative rounded bg-purple-100 px-2 py-1 text-[7px] text-purple-800 border border-purple-200 flex items-center justify-center text-center"
            >
              {btn.buttonText || btn.text || "(unnamed)"}

              <Handle
                type="source"
                position={Position.Right}
                id={`button-${index}`}
                style={{
                  top: "50%",
                  transform: "translateY(-50%)",
                  right: -5,
                  width: 7,
                  height: 7,
                  background: "#8b5cf6",
                  borderRadius: "50%",
                }}
              />
            </div>
          ))}
        </div>
      )}

      {/* Tag info */}
      {type === "tag" && config.tags?.length > 0 && (
        <div className="mt-0.5 text-[7px] text-zinc-600">
          Tags: {config.tags.join(", ")}
        </div>
      )}

      {/* Wait info */}
      {type === "wait" && config.seconds && (
        <div className="mt-0.5 text-[7px] text-zinc-600">
          Wait for {config.seconds} seconds
        </div>
      )}
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplyNodeEditor.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplyNodeEditor.jsx

import React, { useState, useEffect, useCallback } from "react";
import { Dialog } from "@headlessui/react";
import { Button } from "../../../components/ui/button";
import WhatsAppTemplatePreview from "./WhatsAppTemplatePreview";
import axiosClient from "../../../api/axiosClient";

export default function AutoReplyNodeEditor({ node, onClose, onSave }) {
  const [form, setForm] = useState({
    text: "",
    templateName: "",
    placeholders: [],
    tags: [],
    seconds: 10, // üîÅ default wait = 10s
    body: "",
    multiButtons: [],
    // üÜï CTA flow fields
    ctaFlowConfigId: "",
    ctaFlowName: "",
  });

  const [templates, setTemplates] = useState([]);
  const [selectedTemplate, setSelectedTemplate] = useState(null);

  // üÜï CTA flow list for dropdown
  const [ctaFlows, setCtaFlows] = useState([]);

  const isTemplateNode = node?.type === "template";
  const isMessageNode = node?.type === "message";
  const isTagNode = node?.type === "tag";
  const isWaitNode = node?.type === "wait";
  const isCtaNode = node?.type === "cta_flow";

  // ---- API calls ----

  const fetchFullTemplate = useCallback(async templateName => {
    const businessId = localStorage.getItem("businessId");
    if (!businessId || !templateName) return;

    try {
      const { data } = await axiosClient.get(
        `WhatsAppTemplateFetcher/get-by-name/${businessId}/${encodeURIComponent(
          templateName
        )}`,
        {
          params: { includeButtons: true },
        }
      );

      if (data?.success) {
        const tpl = data.template;
        setSelectedTemplate(tpl);

        // Store body + buttons into config
        setForm(prev => ({
          ...prev,
          templateName: tpl.name,
          body: tpl.body || tpl.bodyText || "",
          multiButtons: tpl.multiButtons || tpl.buttonParams || [],
        }));
      } else {
        setSelectedTemplate(null);
        console.warn("‚ö†Ô∏è No template found");
      }
    } catch (err) {
      console.error("‚ùå Failed to fetch full template", err);
      setSelectedTemplate(null);
    }
  }, []);

  const fetchTemplates = useCallback(
    async (preselectedName = "") => {
      const businessId = localStorage.getItem("businessId");
      if (!businessId) return;

      try {
        const { data } = await axiosClient.get(
          `WhatsAppTemplateFetcher/get-template/${businessId}`
        );

        if (data?.success) {
          setTemplates(data.templates || []);
          if (preselectedName) {
            await fetchFullTemplate(preselectedName);
          }
        }
      } catch (err) {
        console.error("‚ùå Failed to fetch templates", err);
      }
    },
    [fetchFullTemplate]
  );

  // üÜï Load all published CTA flows for this business
  const fetchCtaFlows = useCallback(async () => {
    try {
      const { data } = await axiosClient.get("cta-flow/all-published");
      // data is List<VisualFlowSummaryDto> from API
      // { id, flowName, isPublished, createdAt }
      setCtaFlows(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error("‚ùå Failed to fetch CTA flows", err);
      setCtaFlows([]);
    }
  }, []);

  // ---- Initialize form from node.data.config ----

  useEffect(() => {
    if (!node) return;

    const { config } = node.data || {};

    // üî¢ Safely normalize seconds (can be number or string in config)
    const rawSeconds = config?.seconds;
    let normalizedSeconds = 10; // default

    if (typeof rawSeconds === "number") {
      normalizedSeconds = rawSeconds > 0 ? rawSeconds : 10;
    } else if (typeof rawSeconds === "string" && rawSeconds.trim() !== "") {
      const parsed = Number(rawSeconds);
      normalizedSeconds = Number.isFinite(parsed) && parsed > 0 ? parsed : 10;
    }

    const next = {
      text: config?.text || "",
      templateName: config?.templateName || "",
      placeholders: config?.placeholders || [],
      tags: config?.tags || [],
      seconds: normalizedSeconds,
      body: config?.body || "",
      multiButtons: config?.multiButtons || [],
      // üÜï hydrate CTA fields if present
      ctaFlowConfigId: config?.ctaFlowConfigId || config?.CtaFlowConfigId || "",
      ctaFlowName: config?.ctaFlowName || config?.CtaFlowName || "",
    };
    setForm(next);

    if (node.type === "template") {
      fetchTemplates(config?.templateName);
      setSelectedTemplate(null); // will be set in fetchFullTemplate
    } else {
      setSelectedTemplate(null);
    }

    if (node.type === "cta_flow") {
      fetchCtaFlows();
    }
  }, [node, fetchTemplates, fetchCtaFlows]);

  // ---- Handlers ----

  const handleChange = e => {
    const { name, value, type, checked } = e.target;
    setForm(prev => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value,
    }));
  };

  const handleTagsChange = e => {
    const raw = e.target.value;
    const tags = raw
      .split(",")
      .map(t => t.trim())
      .filter(Boolean);
    setForm(prev => ({ ...prev, tags }));
  };

  const handleTemplateChange = e => {
    const value = e.target.value;
    setForm(prev => ({ ...prev, templateName: value }));
    if (value) {
      fetchFullTemplate(value);
    } else {
      setSelectedTemplate(null);
    }
  };

  // üÜï CTA Flow dropdown change
  const handleCtaFlowChange = e => {
    const value = e.target.value;
    const selected = ctaFlows.find(f => f.id === value);

    setForm(prev => ({
      ...prev,
      ctaFlowConfigId: value || "",
      ctaFlowName: selected?.flowName || "",
    }));
  };

  const handleSave = () => {
    if (!node) return;

    // üî¢ Ensure `seconds` is always a number for wait nodes
    let configSeconds = form.seconds;
    if (isWaitNode) {
      const parsed = Number(form.seconds);
      if (!parsed || !Number.isFinite(parsed) || parsed <= 0) {
        configSeconds = 10; // fallback default
      } else {
        configSeconds = parsed;
      }
    }

    const config = {
      ...form,
      ...(isWaitNode ? { seconds: configSeconds } : {}),
    };

    const updated = {
      ...node,
      data: {
        ...(node.data || {}),
        config,
      },
    };

    onSave?.(updated);
    onClose?.();
  };

  const closeWithoutSave = () => {
    setSelectedTemplate(null);
    onClose?.();
  };

  if (!node) return null;

  const title =
    node.type === "message"
      ? "Edit Message Node"
      : node.type === "template"
      ? "Edit Template Node"
      : node.type === "tag"
      ? "Edit Tag Node"
      : node.type === "wait"
      ? "Edit Wait Node"
      : node.type === "cta_flow"
      ? "Edit CTA Flow Node"
      : "Edit Node";

  return (
    <Dialog open={!!node} onClose={closeWithoutSave} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="w-full max-w-lg rounded-lg bg-white shadow-lg p-5 space-y-4">
          <Dialog.Title className="text-lg font-semibold text-gray-900 mb-1">
            {title}
          </Dialog.Title>
          <p className="text-xs text-gray-500 mb-3">
            Node ID: <span className="font-mono">{node.id}</span>
          </p>

          {/* Message node fields */}
          {isMessageNode && (
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">
                Reply text
              </label>
              <textarea
                name="text"
                value={form.text}
                onChange={handleChange}
                rows={4}
                className="w-full border rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
                placeholder="Type the auto-reply message..."
              />
            </div>
          )}

          {/* Template node fields */}
          {isTemplateNode && (
            <div className="space-y-3">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Select WhatsApp template
                </label>
                <select
                  value={form.templateName}
                  onChange={handleTemplateChange}
                  className="w-full border rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
                >
                  <option value="">-- Choose template --</option>
                  {templates.map(tpl => (
                    <option key={tpl.name} value={tpl.name}>
                      {tpl.name} ({tpl.language})
                    </option>
                  ))}
                </select>
                <p className="text-[11px] text-gray-500 mt-1">
                  Templates are loaded from Meta and cached by your backend.
                </p>
              </div>

              {/* Preview of template with buttons */}
              <WhatsAppTemplatePreview template={selectedTemplate} />
            </div>
          )}

          {/* üÜï CTA Flow node fields */}
          {isCtaNode && (
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">
                Attach CTA Flow
              </label>
              <select
                value={form.ctaFlowConfigId}
                onChange={handleCtaFlowChange}
                className="w-full border rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500"
              >
                <option value="">-- Choose published CTA flow --</option>
                {ctaFlows.map(flow => (
                  <option key={flow.id} value={flow.id}>
                    {flow.flowName}
                  </option>
                ))}
              </select>
              <p className="text-[11px] text-gray-500 mt-1">
                This CTA flow is built in the CTA Flow Builder. When this
                auto-reply fires and the user enters that journey, this flow
                will run and log steps into CTA analytics.
              </p>

              {form.ctaFlowName && (
                <p className="text-[11px] text-emerald-700 mt-1">
                  Selected flow: <b>{form.ctaFlowName}</b>
                </p>
              )}
            </div>
          )}

          {/* Tag node fields */}
          {isTagNode && (
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">
                Tags (comma separated)
              </label>
              <input
                type="text"
                value={form.tags.join(", ")}
                onChange={handleTagsChange}
                className="w-full border rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
                placeholder="e.g. new_lead, hot, whatsapp_inbound"
              />
            </div>
          )}

          {/* Wait node fields */}
          {isWaitNode && (
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">
                Wait time (seconds)
              </label>
              <input
                type="number"
                name="seconds"
                min={1}
                value={form.seconds}
                onChange={handleChange}
                className="w-32 border rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
              />
              <p className="text-[11px] text-gray-500">
                The flow will pause for this duration before moving to the next
                node.
              </p>
            </div>
          )}

          {/* Footer actions */}
          <div className="flex justify-end gap-2 pt-3 border-t mt-2">
            <Button
              variant="outline"
              type="button"
              onClick={closeWithoutSave}
              className="text-sm"
            >
              Cancel
            </Button>
            <Button type="button" onClick={handleSave} className="text-sm">
              Save
            </Button>
          </div>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplyNodeStart.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplyNodeStart.jsx
import React from "react";
import { Handle, Position } from "reactflow";

export default function AutoReplyNodeStart({ data }) {
  return (
    <div className="rounded-md border border-green-400 bg-green-100 px-2 py-1.5 w-48 shadow-sm text-[8px] text-zinc-800">
      <Handle
        type="source"
        position={Position.Bottom}
        style={{ background: "#aac0b2" }}
      />

      {/* Header (smaller title) */}
      <div className="font-semibold text-[9px] leading-tight">
        ‚ñ∂ {data.label || "Start"}
      </div>

      {/* Subtitle */}
      <div className="text-[8px] text-zinc-600 mt-0.5">Flow begins here</div>
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\AutoReplySidebar.jsx 
====================================================== 
 
// üìÑ src/pages/AutoReplyBuilder/components/AutoReplySidebar.jsx

import React from "react";
import {
  MessageSquare,
  PlayCircle,
  Hourglass,
  Tag,
  FileText,
  GitBranch, // üÜï for CTA Flow
} from "lucide-react";

const NODE_TYPES = [
  { type: "start", label: "Start", icon: PlayCircle },
  { type: "message", label: "Message", icon: MessageSquare },
  { type: "template", label: "Template", icon: FileText },
  { type: "cta_flow", label: "CTA Flow", icon: GitBranch }, // üÜï CTA Flow node
  { type: "tag", label: "Tag", icon: Tag },
  { type: "wait", label: "Wait", icon: Hourglass },
];

export default function AutoReplySidebar() {
  const onDragStart = (event, nodeType) => {
    event.dataTransfer.setData("application/reactflow", nodeType);
    event.dataTransfer.effectAllowed = "move";
  };

  return (
    <div className="space-y-4">
      <h3 className="text-sm font-semibold text-gray-800">
        Blocks &amp; Actions
      </h3>

      <div className="space-y-3">
        {NODE_TYPES.map(node => {
          const Icon = node.icon;
          return (
            <div
              key={node.type}
              onDragStart={e => onDragStart(e, node.type)}
              draggable
              className="cursor-move flex items-center gap-3 px-4 py-2 rounded-lg border border-gray-300 bg-white hover:shadow-md hover:border-purple-500 transition-all"
            >
              <Icon size={18} className="text-purple-600" />
              <span className="text-sm font-medium text-gray-800">
                {node.label}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\AutoReplyBuilder\components\WhatsAppTemplatePreview.jsx 
====================================================== 
 
import React from "react";

/**
 * üìÑ WhatsAppTemplatePreview
 * @param {Object} props.template - Template metadata from backend
 */
export default function WhatsAppTemplatePreview({ template }) {
  if (!template) return null;

  const {
    name,
    language,
    body,
    bodyText,
    placeholderCount,
    hasImageHeader,
    multiButtons = [],
  } = template;

  const finalBody = body || bodyText || "No content";

  return (
    <div className="mt-4 border rounded-md bg-green-50 px-4 py-3 text-sm text-zinc-800 shadow-sm">
      {/* Header */}
      <div className="mb-2">
        <span className="text-xs font-semibold text-green-700">
          üü¢ WhatsApp Template Preview
        </span>
      </div>

      {/* Template Name + Language */}
      <div className="text-xs mb-2 text-zinc-500">
        <span className="mr-2">
          üìÑ <strong>{name}</strong>
        </span>
        <span className="ml-2">üåê {language}</span>
        <span className="ml-2">üî¢ {placeholderCount} placeholders</span>
      </div>

      {/* Image Header */}
      {hasImageHeader && (
        <div className="mb-2 rounded-md bg-gray-200 text-xs text-center text-gray-600 py-1">
          üñºÔ∏è Image Header Enabled
        </div>
      )}

      {/* Body */}
      <div className="bg-white border border-gray-200 rounded-md px-3 py-2 whitespace-pre-wrap">
        {finalBody}
      </div>

      {/* Buttons */}
      {multiButtons.length > 0 && (
        <div className="mt-3 space-y-1">
          {multiButtons.map((btn, index) => (
            <div
              key={index}
              className="flex items-center justify-between border border-green-200 rounded px-3 py-1 bg-green-100 text-xs"
            >
              <div className="font-medium">{btn.buttonText}</div>
              <div className="text-gray-600">
                {btn.buttonType}{" "}
                {btn.targetUrl && (
                  <span className="text-gray-500 italic">
                    ({btn.targetUrl})
                  </span>
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
 
 
