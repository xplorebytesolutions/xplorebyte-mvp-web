Folder and File Content Report
Root folder: D:\xbytechat\xbytechat-ui\src\pages\Inbox
Generated at: 08-12-2025 10:59:50.51
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\InboxContext.jsx 
====================================================== 
 
import React, { createContext, useContext, useState, useEffect } from "react";
import useSignalR from "../../hooks/useSignalR";
import axiosClient from "../../api/axiosClient";
import { toast } from "react-toastify";

const InboxContext = createContext();

export const useInbox = () => useContext(InboxContext);

export const InboxProvider = ({ children }) => {
  // All state is managed here
  const { connection, isConnected } = useSignalR();
  const [messages, setMessages] = useState([]);
  const [selectedContactId, setSelectedContactId] = useState(null);
  const [newMessage, setNewMessage] = useState("");
  const [contact, setContact] = useState(null);
  const [playSound, setPlaySound] = useState(
    localStorage.getItem("playSound") === "true"
  );
  const [userHasInteracted, setUserHasInteracted] = useState(false);

  const currentUserId = localStorage.getItem("userId");

  // Track user interaction for sound autoplay
  useEffect(() => {
    const handleUserInteraction = () => setUserHasInteracted(true);
    window.addEventListener("click", handleUserInteraction);
    window.addEventListener("keydown", handleUserInteraction);
    return () => {
      window.removeEventListener("click", handleUserInteraction);
      window.removeEventListener("keydown", handleUserInteraction);
    };
  }, []);

  // Fetch contact details when a contact is selected
  useEffect(() => {
    if (!selectedContactId) {
      setContact(null);
      return;
    }
    axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
      setContact(res.data);
    });
  }, [selectedContactId]);

  // Load message history with robust clearing logic
  useEffect(() => {
    if (!selectedContactId) {
      setMessages([]);
      return;
    }
    setMessages([]); // Instantly clear old messages for better UX
    axiosClient
      .get(`/inbox/messages?contactId=${selectedContactId}`)
      .then(res => {
        const normalized = (res.data || []).map(m => ({
          ...m,
          messageContent: m.messageContent ?? m.message, // ‚úÖ normalize
        }));
        setMessages(normalized);
      })
      .catch(err => {
        console.error("‚ùå Failed to load messages:", err);
        toast.error("Failed to load messages.");
      });
  }, [selectedContactId]);

  // SignalR listener for incoming messages
  useEffect(() => {
    if (!connection) return;

    const handler = incoming => {
      const normalized = {
        ...incoming,
        messageContent: incoming.messageContent ?? incoming.message, // ‚úÖ normalize
      };

      if (
        normalized.contactId !== selectedContactId &&
        playSound &&
        userHasInteracted
      ) {
        new Audio("/sounds/inbox_notify.mp3").play().catch(() => {});
      }

      if (normalized.contactId === selectedContactId) {
        setMessages(prev => {
          if (!normalized.isIncoming) {
            // This is our own message coming back from the server; replace the temp one
            return prev.map(m => (m.status === "Sending" ? normalized : m));
          }
          // This is a new message from the contact; add it to the end
          return [...prev, normalized];
        });
      }
    };

    connection.on("ReceiveInboxMessage", handler);
    return () => connection.off("ReceiveInboxMessage", handler);
  }, [connection, selectedContactId, playSound, userHasInteracted]);

  // Function to toggle notification sound
  const toggleSound = async () => {
    const newVal = !playSound;
    if (newVal) {
      try {
        await new Audio("/sounds/inbox_notify.mp3").play();
        setPlaySound(true);
        localStorage.setItem("playSound", "true");
      } catch (err) {
        toast.error("üîá Browser blocked sound. Please enable autoplay.");
        setPlaySound(false);
        localStorage.setItem("playSound", "false");
      }
    } else {
      setPlaySound(false);
      localStorage.setItem("playSound", "false");
    }
  };

  // Function to send a message with optimistic UI
  const sendMessage = async () => {
    if (!selectedContactId || !newMessage.trim() || !isConnected) return;

    const tempId = `temp_${Date.now()}`;
    const optimisticMessage = {
      id: tempId,
      contactId: selectedContactId,
      messageContent: newMessage, // ‚úÖ consistent
      isIncoming: false,
      sentAt: new Date().toISOString(),
      status: "Sending",
    };

    setMessages(prev => [...prev, optimisticMessage]);
    setNewMessage("");

    try {
      await connection.invoke("SendMessageToContact", {
        contactId: selectedContactId,
        message: newMessage, // backend DTO expects "message"
      });
    } catch (err) {
      console.error("‚ùå Send failed:", err);
      toast.error("Failed to send message.");
      setMessages(prev =>
        prev.map(m => (m.id === tempId ? { ...m, status: "Failed" } : m))
      );
    }
  };

  // The value provided to all consumer components
  const value = {
    connection,
    isConnected,
    messages,
    selectedContactId,
    setSelectedContactId,
    newMessage,
    setNewMessage,
    contact,
    playSound,
    toggleSound,
    sendMessage,
    currentUserId,
  };

  return (
    <InboxContext.Provider value={value}>{children}</InboxContext.Provider>
  );
};

// import React, { createContext, useContext, useState, useEffect } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";

// const InboxContext = createContext();

// export const useInbox = () => useContext(InboxContext);

// export const InboxProvider = ({ children }) => {
//   // All state is managed here
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [playSound, setPlaySound] = useState(
//     localStorage.getItem("playSound") === "true"
//   );
//   const [userHasInteracted, setUserHasInteracted] = useState(false);

//   const currentUserId = localStorage.getItem("userId");

//   // Track user interaction for sound autoplay
//   useEffect(() => {
//     const handleUserInteraction = () => setUserHasInteracted(true);
//     window.addEventListener("click", handleUserInteraction);
//     window.addEventListener("keydown", handleUserInteraction);
//     return () => {
//       window.removeEventListener("click", handleUserInteraction);
//       window.removeEventListener("keydown", handleUserInteraction);
//     };
//   }, []);

//   // Fetch contact details when a contact is selected
//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   // Load message history with robust clearing logic
//   useEffect(() => {
//     if (!selectedContactId) {
//       setMessages([]);
//       return;
//     }
//     setMessages([]); // Instantly clear old messages for better UX
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   // SignalR listener for incoming messages
//   useEffect(() => {
//     if (!connection) return;
//     const handler = incoming => {
//       if (
//         incoming.contactId !== selectedContactId &&
//         playSound &&
//         userHasInteracted
//       ) {
//         new Audio("/sounds/inbox_notify.mp3").play().catch(() => {});
//       }

//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev => {
//           if (!incoming.isIncoming) {
//             // This is our own message coming back from the server; replace the temp one
//             return prev.map(m => (m.status === "Sending" ? incoming : m));
//           }
//           // This is a new message from the contact; add it to the end
//           return [...prev, incoming];
//         });
//       }
//     };

//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, playSound, userHasInteracted]);

//   // Function to toggle notification sound
//   const toggleSound = async () => {
//     const newVal = !playSound;
//     if (newVal) {
//       try {
//         await new Audio("/sounds/inbox_notify.mp3").play();
//         setPlaySound(true);
//         localStorage.setItem("playSound", "true");
//       } catch (err) {
//         toast.error("üîá Browser blocked sound. Please enable autoplay.");
//         setPlaySound(false);
//         localStorage.setItem("playSound", "false");
//       }
//     } else {
//       setPlaySound(false);
//       localStorage.setItem("playSound", "false");
//     }
//   };

//   // Function to send a message with optimistic UI
//   const sendMessage = async () => {
//     if (!selectedContactId || !newMessage.trim() || !isConnected) return;

//     const tempId = `temp_${Date.now()}`;
//     const optimisticMessage = {
//       id: tempId,
//       contactId: selectedContactId,
//       messageContent: newMessage,
//       isIncoming: false,
//       sentAt: new Date().toISOString(),
//       status: "Sending",
//     };

//     setMessages(prev => [...prev, optimisticMessage]);
//     setNewMessage("");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//       setMessages(prev =>
//         prev.map(m => (m.id === tempId ? { ...m, status: "Failed" } : m))
//       );
//     }
//   };

//   // The value provided to all consumer components
//   const value = {
//     connection,
//     isConnected,
//     messages,
//     selectedContactId,
//     setSelectedContactId,
//     newMessage,
//     setNewMessage,
//     contact,
//     playSound,
//     toggleSound,
//     sendMessage,
//     currentUserId,
//   };

//   return (
//     <InboxContext.Provider value={value}>{children}</InboxContext.Provider>
//   );
// };
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\InboxWrapper.jsx 
====================================================== 
 
import React, { useState, useEffect } from "react";
import { InboxProvider, useInbox } from "./InboxContext";
import InboxSidebar from "./components/InboxSidebar";
import ChatWindow from "./components/ChatWindow";
import ChatInput from "./components/ChatInput";
import ContactSidebar from "./components/ContactSidebar";
import ChatHeader from "./components/ChatHeader";
import { ChevronLeft, ChevronRight, Bell } from "lucide-react";

// The layout component gets its data from our new hook
function InboxLayout() {
  const {
    selectedContactId,
    setSelectedContactId,
    currentUserId,
    playSound,
    toggleSound,
  } = useInbox();

  const [showRightPanel, setShowRightPanel] = useState(true);

  // Control body scrolling when inbox is mounted
  useEffect(() => {
    // Store original styles
    const originalBodyOverflow = document.body.style.overflow;
    const originalHtmlOverflow = document.documentElement.style.overflow;

    // Add classes to prevent scrolling
    document.body.classList.add("inbox-active");
    document.documentElement.classList.add("inbox-active");

    // Force prevent scrolling
    document.body.style.overflow = "hidden";
    document.documentElement.style.overflow = "hidden";

    // Cleanup function to restore original styles
    return () => {
      document.body.classList.remove("inbox-active");
      document.documentElement.classList.remove("inbox-active");
      document.body.style.overflow = originalBodyOverflow;
      document.documentElement.style.overflow = originalHtmlOverflow;
    };
  }, []);

  return (
    <div className="inbox-fullscreen h-screen flex flex-col overflow-hidden">
      <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
        <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
          <span className="text-xl">üì®</span>
          Inbox
        </div>
        <div className="flex items-center gap-4">
          <button
            onClick={toggleSound}
            className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
              playSound
                ? "bg-green-100 text-green-600 border-green-300"
                : "bg-gray-100 text-gray-500 border-gray-300"
            }`}
          >
            <Bell size={14} /> {playSound ? "Sound ON" : "Sound OFF"}
          </button>
        </div>
      </header>

      <div className="flex flex-1 overflow-hidden">
        {/* Left Sidebar - Always visible */}
        <div
          className="bg-white border-r overflow-y-auto"
          style={{
            width: "288px",
            minWidth: "288px",
            maxWidth: "288px",
            height: "100%",
          }}
        >
          <InboxSidebar
            onSelect={id => setSelectedContactId(id)}
            currentUserId={currentUserId}
          />
        </div>

        <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
          <button
            className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
            onClick={() => setShowRightPanel(!showRightPanel)}
            title={showRightPanel ? "Hide contact info" : "Show contact info"}
          >
            {showRightPanel ? (
              <ChevronRight size={16} />
            ) : (
              <ChevronLeft size={16} />
            )}
          </button>

          {selectedContactId ? (
            <>
              {/* Chat Header - Fixed at top */}
              <div className="shrink-0">
                <ChatHeader contactId={selectedContactId} />
              </div>

              {/* Chat Window - Scrollable area that takes remaining space */}
              <div className="flex-1 overflow-hidden">
                <ChatWindow />
              </div>

              {/* Chat Input - Fixed at bottom */}
              <div className="shrink-0" style={{ flexShrink: 0 }}>
                <ChatInput />
              </div>
            </>
          ) : (
            <div className="flex-1 flex items-center justify-center text-gray-400">
              Please select a contact to start chatting.
            </div>
          )}
        </div>

        {showRightPanel && selectedContactId && (
          <div
            className="w-80 border-l bg-white overflow-y-auto"
            style={{ height: "100%", maxHeight: "100%" }}
          >
            <ContactSidebar contactId={selectedContactId} />
          </div>
        )}
      </div>
    </div>
  );
}

// The final export wraps our layout with the provider
export default function InboxWrapper() {
  return (
    <InboxProvider>
      <InboxLayout />
    </InboxProvider>
  );
}
// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight, Bell } from "lucide-react";
// import { InboxProvider, useInbox } from "./InboxContext";
// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);
//   const [playSound, setPlaySound] = useState(
//     localStorage.getItem("playSound") === "true"
//   );
//   const [userHasInteracted, setUserHasInteracted] = useState(false);

//   const currentUserId = localStorage.getItem("userId");

//   // ‚úÖ Track first user interaction to allow audio play
//   useEffect(() => {
//     const handleUserInteraction = () => setUserHasInteracted(true);
//     window.addEventListener("click", handleUserInteraction);
//     window.addEventListener("keydown", handleUserInteraction);
//     return () => {
//       window.removeEventListener("click", handleUserInteraction);
//       window.removeEventListener("keydown", handleUserInteraction);
//     };
//   }, []);

//   // üîä Sound toggle with permission
//   const toggleSound = async () => {
//     const newVal = !playSound;

//     if (newVal) {
//       try {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         await audio.play();
//         audio.pause();
//         setPlaySound(true);
//         localStorage.setItem("playSound", "true");
//       } catch (err) {
//         toast.error("üîá Browser blocked sound. Allow autoplay.");
//         console.warn("‚ö†Ô∏è Audio play blocked:", err);
//         setPlaySound(false);
//         localStorage.setItem("playSound", "false");
//       }
//     } else {
//       setPlaySound(false);
//       localStorage.setItem("playSound", "false");
//     }
//   };

//   // üìû Fetch contact info on select
//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   // üì© Load message history
//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   // üöÄ Send message
//   // const sendMessage = async () => {
//   //   if (!selectedContactId)
//   //     return toast.error("‚ùó Please select a contact first.");
//   //   if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//   //   if (!connection || !isConnected)
//   //     return toast.error("‚ùå SignalR not connected.");

//   //   try {
//   //     await connection.invoke("SendMessageToContact", {
//   //       contactId: selectedContactId,
//   //       message: newMessage,
//   //     });
//   //     setNewMessage("");
//   //   } catch (err) {
//   //     console.error("‚ùå Send failed:", err);
//   //     toast.error("Failed to send message.");
//   //   }
//   // };
//   const sendMessage = async () => {
//     if (!selectedContactId || !newMessage.trim()) return;
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     // 1. Create a temporary message for optimistic UI
//     const tempId = `temp_${Date.now()}`;
//     const optimisticMessage = {
//       id: tempId,
//       contactId: selectedContactId,
//       messageContent: newMessage,
//       isIncoming: false,
//       sentAt: new Date().toISOString(),
//       status: "Sending", // Special status for the UI
//     };

//     // 2. Add to state immediately and clear input
//     setMessages(prevMessages => [...prevMessages, optimisticMessage]);
//     setNewMessage("");

//     try {
//       // 3. Send to server
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//         // Optional: send tempId to make replacement easier
//         // tempId: tempId
//       });
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//       // Handle error: update the optimistic message to show a "Failed" status
//       setMessages(prev =>
//         prev.map(m => (m.id === tempId ? { ...m, status: "Failed" } : m))
//       );
//     }
//   };
//   // üîî Real-time message listener
//   // useEffect(() => {
//   //   if (!connection) return;

//   //   const handler = incoming => {
//   //     if (
//   //       incoming.contactId !== selectedContactId &&
//   //       playSound &&
//   //       userHasInteracted
//   //     ) {
//   //       try {
//   //         const audio = new Audio("/sounds/inbox_notify.mp3");
//   //         audio.play().catch(err => {
//   //           console.warn("üîá Browser prevented sound playback:", err);
//   //         });
//   //       } catch (err) {
//   //         console.warn("‚ùå Sound error:", err);
//   //       }
//   //     }

//   //     if (incoming.contactId === selectedContactId) {
//   //       setMessages(prev =>
//   //         [...prev, incoming].sort(
//   //           (a, b) =>
//   //             new Date(a.sentAt || a.createdAt) -
//   //             new Date(b.sentAt || b.createdAt)
//   //         )
//   //       );
//   //     }
//   //   };
//   useEffect(() => {
//     if (!connection) return;

//     const handler = incoming => {
//       // ... sound playing logic ...

//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev => {
//           // If the message is from the current user, replace the temp message
//           if (!incoming.isIncoming) {
//             return prev.map(m => (m.status === "Sending" ? incoming : m));
//           }
//           // Otherwise, just add the new incoming message
//           return [...prev, incoming];
//         });
//       }
//     };
//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, playSound, userHasInteracted]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           <span className="text-xl">üì®</span> Inbox
//         </div>
//         <div className="flex items-center gap-4">
//           <button
//             onClick={toggleSound}
//             className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
//               playSound
//                 ? "bg-green-100 text-green-600 border-green-300"
//                 : "bg-gray-100 text-gray-500 border-gray-300"
//             }`}
//           >
//             <Bell size={14} /> {playSound ? "Sound ON" : "Sound OFF"}
//           </button>
//         </div>
//       </header>

//       {/* üí¨ Main layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar
//             onSelect={id => setSelectedContactId(id)}
//             currentUserId={currentUserId}
//           />
//         </div>

//         {/* üí¨ Chat Area */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow
//                   messages={messages}
//                   currentUserId={currentUserId}
//                   selectedContactId={selectedContactId}
//                   connection={connection}
//                 />
//               </div>
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Panel */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight, Bell } from "lucide-react";

// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);
//   const [playSound, setPlaySound] = useState(
//     localStorage.getItem("playSound") === "true"
//   );

//   const currentUserId = localStorage.getItem("userId");

//   // üîä Sound toggle with permission
//   const toggleSound = async () => {
//     const newVal = !playSound;

//     if (newVal) {
//       try {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         await audio.play();
//         audio.pause();
//         setPlaySound(true);
//         localStorage.setItem("playSound", "true");
//       } catch (err) {
//         toast.error("üîá Browser blocked sound. Allow autoplay.");
//         console.warn("‚ö†Ô∏è Audio play blocked:", err);
//         setPlaySound(false);
//         localStorage.setItem("playSound", "false");
//       }
//     } else {
//       setPlaySound(false);
//       localStorage.setItem("playSound", "false");
//     }
//   };

//   // üìû Fetch contact info on select
//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   // üì© Load message history
//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   // üöÄ Send message
//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   // üîî Real-time message listener
//   useEffect(() => {
//     if (!connection) return;

//     const handler = incoming => {
//       if (incoming.contactId !== selectedContactId && playSound) {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         audio.play();
//       }

//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };

//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, playSound]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           <span className="text-xl">üì®</span> Inbox
//         </div>
//         <div className="flex items-center gap-4">
//           <button
//             onClick={toggleSound}
//             className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
//               playSound
//                 ? "bg-green-100 text-green-600 border-green-300"
//                 : "bg-gray-100 text-gray-500 border-gray-300"
//             }`}
//           >
//             <Bell size={14} /> {playSound ? "Sound ON" : "Sound OFF"}
//           </button>
//           <div className="text-sm text-gray-500">xByteChat</div>
//         </div>
//       </header>

//       {/* üí¨ Main layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar
//             onSelect={id => setSelectedContactId(id)}
//             currentUserId={currentUserId}
//           />
//         </div>

//         {/* üí¨ Chat Area */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow
//                   messages={messages}
//                   currentUserId={currentUserId}
//                   selectedContactId={selectedContactId}
//                   connection={connection}
//                 />
//               </div>
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Panel */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight, Bell } from "lucide-react";

// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);
//   const [playSound, setPlaySound] = useState(
//     localStorage.getItem("playSound") === "true"
//   );

//   const currentUserId = localStorage.getItem("userId");

//   const toggleSound = async () => {
//     const newVal = !playSound;

//     if (newVal) {
//       // Try to play dummy sound to get permission
//       try {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         await audio.play();
//         audio.pause();
//         setPlaySound(true);
//         localStorage.setItem("playSound", "true");
//       } catch (err) {
//         toast.error("üîá Your browser blocked sound. Please allow autoplay.");
//         console.warn("‚ö†Ô∏è Audio play blocked:", err);
//         setPlaySound(false);
//         localStorage.setItem("playSound", "false");
//       }
//     } else {
//       setPlaySound(false);
//       localStorage.setItem("playSound", "false");
//     }
//   };

//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   useEffect(() => {
//     if (!connection) return;
//     const handler = incoming => {
//       // ‚úÖ Play sound only if it's from another contact
//       if (incoming.contactId !== selectedContactId && playSound) {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         audio.play();
//       }
//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };
//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, playSound]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           <span className="text-xl">üì®</span> Inbox
//         </div>
//         <div className="flex items-center gap-4">
//           <button
//             onClick={toggleSound}
//             className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
//               playSound
//                 ? "bg-green-100 text-green-600 border-green-300"
//                 : "bg-gray-100 text-gray-500 border-gray-300"
//             }`}
//           >
//             <Bell size={14} /> {playSound ? "Sound ON" : "Sound OFF"}
//           </button>
//           <div className="text-sm text-gray-500">xByteChat</div>
//         </div>
//       </header>

//       {/* üí¨ Main 3-column layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar onSelect={id => setSelectedContactId(id)} />
//         </div>

//         {/* üí¨ Chat column */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow
//                   messages={messages}
//                   currentUserId={currentUserId}
//                   selectedContactId={selectedContactId}
//                   connection={connection}
//                 />
//               </div>
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Contact Info */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight, Bell } from "lucide-react";

// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);
//   const [playSound, setPlaySound] = useState(
//     localStorage.getItem("playSound") === "true"
//   );

//   const currentUserId = localStorage.getItem("userId");

//   const toggleSound = async () => {
//     const newVal = !playSound;

//     if (newVal) {
//       try {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         await audio.play();
//         audio.pause();
//         setPlaySound(true);
//         localStorage.setItem("playSound", "true");
//       } catch (err) {
//         toast.error("üîá Your browser blocked sound. Please allow autoplay.");
//         console.warn("‚ö†Ô∏è Audio play blocked:", err);
//         setPlaySound(false);
//         localStorage.setItem("playSound", "false");
//       }
//     } else {
//       setPlaySound(false);
//       localStorage.setItem("playSound", "false");
//     }
//   };

//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   useEffect(() => {
//     if (!connection) return;

//     const handler = incoming => {
//       if (incoming.contactId !== selectedContactId && playSound) {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         audio.play();
//       }

//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };

//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, playSound]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           üì® Inbox
//         </div>
//         <div className="flex items-center gap-4">
//           <button
//             onClick={toggleSound}
//             className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
//               playSound
//                 ? "bg-green-100 text-green-600 border-green-300"
//                 : "bg-gray-100 text-gray-500 border-gray-300"
//             }`}
//           >
//             <Bell size={14} /> {playSound ? "Sound ON" : "Sound OFF"}
//           </button>
//           <div className="text-sm text-gray-500">xByteChat</div>
//         </div>
//       </header>

//       {/* üí¨ Main 3-column layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar onSelect={id => setSelectedContactId(id)} />
//         </div>

//         {/* üí¨ Chat column */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow messages={messages} currentUserId={currentUserId} />
//               </div>
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Contact Info */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// // ‚úÖ Updated InboxWrapper.jsx with stable notification sound toggle via useNotificationSound
// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import useNotificationSound from "../../hooks/useNotificationSound";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight, Bell } from "lucide-react";

// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);
//   const currentUserId = localStorage.getItem("userId");

//   const { isSoundOn, toggleSound, soundRef } = useNotificationSound();

//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   useEffect(() => {
//     if (!connection) return;

//     const handler = incoming => {
//       // ‚úÖ Use soundRef for latest value
//       if (incoming.contactId !== selectedContactId && soundRef.current) {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         audio.play();
//       }

//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };

//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, soundRef]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           üì® Inbox
//         </div>
//         <div className="flex items-center gap-4">
//           <button
//             onClick={toggleSound}
//             className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
//               isSoundOn
//                 ? "bg-green-100 text-green-600 border-green-300"
//                 : "bg-gray-100 text-gray-500 border-gray-300"
//             }`}
//           >
//             <Bell size={14} /> {isSoundOn ? "Sound ON" : "Sound OFF"}
//           </button>
//           <div className="text-sm text-gray-500">xByteChat</div>
//         </div>
//       </header>

//       {/* üí¨ Main 3-column layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar onSelect={id => setSelectedContactId(id)} />
//         </div>

//         {/* üí¨ Chat column */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow messages={messages} currentUserId={currentUserId} />
//               </div>
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Contact Info */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// ‚úÖ Updated InboxWrapper.jsx with Notification Sound Toggle + Play Logic
// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight, Bell } from "lucide-react";

// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);
//   const [playSound, setPlaySound] = useState(
//     localStorage.getItem("playSound") === "true"
//   );

//   const currentUserId = localStorage.getItem("userId");

//   // const toggleSound = () => {
//   //   const newVal = !playSound;
//   //   setPlaySound(newVal);
//   //   localStorage.setItem("playSound", newVal);
//   // };
//   const toggleSound = async () => {
//     const newVal = !playSound;

//     if (newVal) {
//       // Try to play dummy sound to get permission
//       try {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         await audio.play();
//         audio.pause();
//         setPlaySound(true);
//         localStorage.setItem("playSound", "true");
//       } catch (err) {
//         toast.error("üîá Your browser blocked sound. Please allow autoplay.");
//         console.warn("‚ö†Ô∏è Audio play blocked:", err);
//         setPlaySound(false);
//         localStorage.setItem("playSound", "false");
//       }
//     } else {
//       setPlaySound(false);
//       localStorage.setItem("playSound", "false");
//     }
//   };

//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   useEffect(() => {
//     if (!connection) return;
//     const handler = incoming => {
//       // ‚úÖ Play sound only if it's from another contact
//       if (incoming.contactId !== selectedContactId && playSound) {
//         const audio = new Audio("/sounds/inbox_notify.mp3");
//         audio.play();
//       }
//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };
//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId, playSound]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           üì® Inbox
//         </div>
//         <div className="flex items-center gap-4">
//           <button
//             onClick={toggleSound}
//             className={`text-xs flex items-center gap-1 px-2 py-1 rounded-full border shadow-sm hover:bg-purple-50 ${
//               playSound
//                 ? "bg-green-100 text-green-600 border-green-300"
//                 : "bg-gray-100 text-gray-500 border-gray-300"
//             }`}
//           >
//             <Bell size={14} /> {playSound ? "Sound ON" : "Sound OFF"}
//           </button>
//           <div className="text-sm text-gray-500">xByteChat</div>
//         </div>
//       </header>

//       {/* üí¨ Main 3-column layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar onSelect={id => setSelectedContactId(id)} />
//         </div>

//         {/* üí¨ Chat column */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow messages={messages} currentUserId={currentUserId} />
//               </div>
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Contact Info */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight } from "lucide-react";

// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);

//   const currentUserId = localStorage.getItem("userId");

//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     axiosClient.get(`/contacts/${selectedContactId}`).then(res => {
//       setContact(res.data);
//     });
//   }, [selectedContactId]);

//   useEffect(() => {
//     if (!selectedContactId) return;
//     axiosClient
//       .get(`/inbox/messages?contactId=${selectedContactId}`)
//       .then(res => setMessages(res.data))
//       .catch(err => {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       });
//   }, [selectedContactId]);

//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     try {
//       await connection.invoke("SendMessageToContact", {
//         contactId: selectedContactId,
//         message: newMessage,
//       });
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   useEffect(() => {
//     if (!connection) return;
//     const handler = incoming => {
//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };
//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId]);

//   return (
//     <div className="h-screen flex flex-col overflow-hidden">
//       {/* üîí Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between shrink-0">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           üì® Inbox
//         </div>
//         <div className="text-sm text-gray-500">xByteChat</div>
//       </header>

//       {/* üí¨ Main 3-column layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* üìá Left Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar onSelect={id => setSelectedContactId(id)} />
//         </div>

//         {/* üí¨ Chat column */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] overflow-hidden relative">
//           {/* ‚ÜîÔ∏è Toggle Right Panel */}
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               {/* üßë Contact Header */}
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>

//               {/* üìú Message Scroll Area */}
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow messages={messages} currentUserId={currentUserId} />
//               </div>

//               {/* ‚úèÔ∏è Chat Input (Fixed at bottom) */}
//               <div className="shrink-0">
//                 <ChatInput
//                   value={newMessage}
//                   onChange={e => setNewMessage(e.target.value)}
//                   onSend={sendMessage}
//                   disabled={!isConnected}
//                 />
//               </div>
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* üìá Right Contact Info */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }

// import React, { useEffect, useState } from "react";
// import useSignalR from "../../hooks/useSignalR";
// import InboxSidebar from "./components/InboxSidebar";
// import ChatWindow from "./components/ChatWindow";
// import ChatInput from "./components/ChatInput";
// import ContactSidebar from "./components/ContactSidebar";
// import ChatHeader from "./components/ChatHeader";
// import axiosClient from "../../api/axiosClient";
// import { toast } from "react-toastify";
// import { ChevronLeft, ChevronRight } from "lucide-react";
// import { Inbox } from "lucide-react"; // ‚úÖ Add this at top
// export default function InboxWrapper() {
//   const { connection, isConnected } = useSignalR();
//   const [messages, setMessages] = useState([]);
//   const [selectedContactId, setSelectedContactId] = useState(null);
//   const [newMessage, setNewMessage] = useState("");
//   const [contact, setContact] = useState(null);
//   const [showRightPanel, setShowRightPanel] = useState(true);

//   const currentUserId = localStorage.getItem("userId");

//   useEffect(() => {
//     if (!selectedContactId) {
//       setContact(null);
//       return;
//     }
//     const loadContact = async () => {
//       try {
//         const res = await axiosClient.get(`/contacts/${selectedContactId}`);
//         setContact(res.data);
//       } catch (err) {
//         console.error("‚ùå Failed to load contact:", err);
//       }
//     };
//     loadContact();
//   }, [selectedContactId]);

//   useEffect(() => {
//     if (!selectedContactId) return;
//     const loadMessages = async () => {
//       try {
//         const res = await axiosClient.get(
//           `/inbox/messages?contactId=${selectedContactId}`
//         );
//         setMessages(res.data);
//       } catch (err) {
//         console.error("‚ùå Failed to load messages:", err);
//         toast.error("Failed to load messages.");
//       }
//     };
//     loadMessages();
//   }, [selectedContactId]);

//   const sendMessage = async () => {
//     if (!selectedContactId)
//       return toast.error("‚ùó Please select a contact first.");
//     if (!newMessage.trim()) return toast.warn("‚ö†Ô∏è Please type a message.");
//     if (!connection || !isConnected)
//       return toast.error("‚ùå SignalR not connected.");

//     const payload = {
//       contactId: selectedContactId,
//       message: newMessage,
//     };

//     try {
//       await connection.invoke("SendMessageToContact", payload);
//       setNewMessage("");
//     } catch (err) {
//       console.error("‚ùå Send failed:", err);
//       toast.error("Failed to send message.");
//     }
//   };

//   useEffect(() => {
//     if (!connection) return;
//     const handler = incoming => {
//       if (incoming.contactId === selectedContactId) {
//         setMessages(prev =>
//           [...prev, incoming].sort(
//             (a, b) =>
//               new Date(a.sentAt || a.createdAt) -
//               new Date(b.sentAt || b.createdAt)
//           )
//         );
//       }
//     };
//     connection.on("ReceiveInboxMessage", handler);
//     return () => connection.off("ReceiveInboxMessage", handler);
//   }, [connection, selectedContactId]);

//   return (
//     <div className="flex flex-col h-screen bg-white">
//       {/* üü£ Top App Bar */}
//       <header className="h-12 bg-white border-b shadow-sm px-6 flex items-center justify-between">
//         <div className="flex items-center gap-2 text-purple-600 font-semibold text-base">
//           <Inbox size={18} className="text-purple-600" />
//           Inbox
//         </div>
//         <div className="text-sm text-gray-500">xByteChat</div>
//       </header>

//       {/* üí¨ Main Body Layout */}
//       <div className="flex flex-1 overflow-hidden">
//         {/* Sidebar */}
//         <div className="w-72 border-r bg-white overflow-y-auto">
//           <InboxSidebar onSelect={id => setSelectedContactId(id)} />
//         </div>

//         {/* Chat Column */}
//         <div className="flex flex-col flex-1 bg-[#f0f0eb] relative">
//           {/* Toggle Right Panel Button */}
//           <button
//             className="absolute right-2 top-2 z-10 bg-white border shadow-sm rounded-full p-1 text-gray-500 hover:text-purple-600"
//             onClick={() => setShowRightPanel(!showRightPanel)}
//             title={showRightPanel ? "Hide contact info" : "Show contact info"}
//           >
//             {showRightPanel ? (
//               <ChevronRight size={16} />
//             ) : (
//               <ChevronLeft size={16} />
//             )}
//           </button>

//           {selectedContactId ? (
//             <>
//               {/* Chat Header (Not Sticky) */}
//               <div className="shrink-0">
//                 <ChatHeader contact={contact} />
//               </div>

//               {/* Scrollable Chat Window */}
//               <div className="flex-1 overflow-y-auto">
//                 <ChatWindow
//                   messages={messages}
//                   currentUserId={currentUserId}
//                   contact={contact}
//                 />
//               </div>

//               {/* Input */}
//               <ChatInput
//                 value={newMessage}
//                 onChange={e => setNewMessage(e.target.value)}
//                 onSend={sendMessage}
//                 disabled={!isConnected}
//               />
//             </>
//           ) : (
//             <div className="flex-1 flex items-center justify-center text-gray-400">
//               Please select a contact to start chatting.
//             </div>
//           )}
//         </div>

//         {/* Right Panel */}
//         {showRightPanel && selectedContactId && (
//           <div className="w-80 border-l bg-white overflow-y-auto">
//             <ContactSidebar contactId={selectedContactId} />
//           </div>
//         )}
//       </div>
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\MakeDump.bat 
====================================================== 
 
@echo off
REM This script will find relevant source files and output their names and contents into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh and write a small header
> "%outputFile%" (
    echo Folder and File Content Report
    echo Root folder: %cd%
    echo Generated at: %date% %time%
)
echo. >> "%outputFile%"

REM NOTE:
REM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)
REM This keeps the file smaller and much easier to review.

REM Loop through all relevant files in the current directory and subdirectories
REM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML
for /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (

    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)
    echo "%%F" | findstr /I /C:"\node_modules\" /C:"\bin\" /C:"\obj\" /C:"\.git\" /C:"\dist\" /C:"\.vs\" >nul
    if errorlevel 1 (
        echo ====================================================== >> "%outputFile%"
        echo FILE: %%F >> "%outputFile%"
        echo ====================================================== >> "%outputFile%"
        echo. >> "%outputFile%"
        type "%%F" >> "%outputFile%" 2>nul
        echo. >> "%outputFile%"
        echo. >> "%outputFile%"
    )
)

echo Finished! All content has been extracted to %outputFile%
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\ChatBubble.jsx 
====================================================== 
 
import React, { useState, useRef, useEffect } from "react";
import dayjs from "dayjs";
import {
  FaCheck,
  FaCheckDouble,
  FaClock,
  FaExclamationCircle,
} from "react-icons/fa";

export default function ChatBubble({ message, isOwn }) {
  const [expanded, setExpanded] = useState(false);
  const messageRef = useRef(null);
  const [isOverflowing, setIsOverflowing] = useState(false);

  const time = dayjs(message.sentAt || message.createdAt).format("h:mm A");
  const messageText =
    message.renderedBody ||
    message.message ||
    message.messageContent ||
    "[no message]";

  useEffect(() => {
    const el = messageRef.current;
    if (el && el.scrollHeight > el.clientHeight + 10) {
      setIsOverflowing(true);
    }
  }, []);

  const baseStyle =
    "px-4 py-2 max-w-[75%] text-sm leading-snug shadow-md whitespace-pre-wrap";

  const ownStyle = "bg-green-600 text-white rounded-2xl rounded-br-sm";
  const incomingStyle = "bg-purple-100 text-gray-900 rounded-2xl rounded-bl-sm";

  const tickColor = isOwn ? "text-white/70" : "text-gray-500";

  return (
    <div className={`flex ${isOwn ? "justify-end" : "justify-start"} mb-2`}>
      <div
        ref={messageRef}
        onClick={() => isOverflowing && setExpanded(!expanded)}
        className={`${baseStyle} ${isOwn ? ownStyle : incomingStyle} ${
          expanded ? "cursor-zoom-out" : isOverflowing ? "cursor-zoom-in" : ""
        }`}
        style={{
          overflow: "hidden",
          whiteSpace: expanded ? "normal" : "pre-wrap",
        }}
      >
        <div className="flex items-end justify-between gap-2">
          <span className="flex-1">{messageText}</span>
          <span className={`text-[11px] flex items-center gap-1 ${tickColor}`}>
            {time}
            {isOwn && (
              <>
                {/* {message.status === "Sent" && <FaCheck />}
                {message.status === "Delivered" && <FaCheckDouble />}
                {message.status === "Read" && (
                  <FaCheckDouble className="text-blue-400" />
                )} */}
                {message.status === "Sending" && <FaClock />}
                {message.status === "Failed" && (
                  <FaExclamationCircle className="text-red-400" />
                )}
                {message.status === "Sent" && <FaCheck />}
                {message.status === "Delivered" && <FaCheckDouble />}
                {message.status === "Read" && (
                  <FaCheckDouble className="text-blue-400" />
                )}
              </>
            )}
          </span>
        </div>
      </div>
    </div>
  );
}

// import React, { useState, useRef, useEffect } from "react";
// import dayjs from "dayjs";
// import { FaCheck, FaCheckDouble } from "react-icons/fa";

// export default function ChatBubble({ message, isOwn }) {
//   const [expanded, setExpanded] = useState(false);
//   const messageRef = useRef(null);
//   const [isOverflowing, setIsOverflowing] = useState(false);

//   const time = dayjs(message.sentAt || message.createdAt).format("h:mm A");
//   const messageText =
//     message.renderedBody ||
//     message.message ||
//     message.messageContent ||
//     "[no message]";

//   useEffect(() => {
//     const el = messageRef.current;
//     if (el && el.scrollHeight > el.clientHeight + 10) {
//       setIsOverflowing(true);
//     }
//   }, []);

//   const baseStyle =
//     "px-4 py-2 max-w-[75%] text-sm leading-snug shadow-md whitespace-pre-wrap";

//   const ownStyle = "bg-green-600 text-white rounded-2xl rounded-br-sm";
//   const incomingStyle = "bg-purple-100 text-gray-900 rounded-2xl rounded-bl-sm";

//   const tickColor = isOwn ? "text-white/70" : "text-gray-500";

//   return (
//     <div className={`flex ${isOwn ? "justify-end" : "justify-start"} mb-2`}>
//       <div
//         ref={messageRef}
//         onClick={() => isOverflowing && setExpanded(!expanded)}
//         className={`${baseStyle} ${isOwn ? ownStyle : incomingStyle} ${
//           expanded ? "cursor-zoom-out" : isOverflowing ? "cursor-zoom-in" : ""
//         }`}
//         style={{
//           overflow: "hidden",
//           whiteSpace: expanded ? "normal" : "pre-wrap",
//         }}
//       >
//         <div className="flex items-end justify-between gap-2">
//           <span className="flex-1">
//             {messageText}
//             {message.campaignName && (
//               <div className="mt-1 text-[10px] italic text-white/80">
//                 üì¢ Sent via campaign: {message.campaignName}
//               </div>
//             )}
//           </span>

//           <span className={`text-[11px] flex items-center gap-1 ${tickColor}`}>
//             {time}
//             {isOwn && (
//               <>
//                 {message.status === "Sent" && <FaCheck />}
//                 {message.status === "Delivered" && <FaCheckDouble />}
//                 {message.status === "Read" && (
//                   <FaCheckDouble className="text-blue-400" />
//                 )}
//               </>
//             )}
//           </span>
//         </div>
//       </div>
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\ChatHeader.jsx 
====================================================== 
 
import React, { useEffect, useState } from "react";
import axiosClient from "../../../api/axiosClient";

/**
 * ChatHeader ‚Äî Professional WhatsApp-style chat header
 * Props:
 * - contactId: contact ID to fetch data
 */
export default function ChatHeader({ contactId }) {
  const [contact, setContact] = useState(null);

  // Fetch contact data when contactId changes
  useEffect(() => {
    if (!contactId) {
      setContact(null);
      return;
    }

    const fetchContact = async () => {
      try {
        const res = await axiosClient.get(`/contacts/${contactId}`);
        // Handle different API response structures
        if (res?.data?.data) {
          setContact(res.data.data);
        } else if (res?.data) {
          setContact(res.data);
        } else {
          setContact(res);
        }
      } catch (err) {
        console.error("‚ùå [ChatHeader] Failed to load contact:", err);
      }
    };

    fetchContact();
  }, [contactId]);

  if (!contact) return null;

  const { name, phoneNumber } = contact;

  // üß† Extract initials from name or phone number
  const initials =
    name
      ?.split(" ")
      .map(part => part.charAt(0).toUpperCase())
      .slice(0, 2)
      .join("") ||
    phoneNumber?.slice(-2) ||
    "??";

  // Display name if present, otherwise phone number
  const displayName = name || phoneNumber || "Unknown Contact";

  return (
    <div className="bg-white border-b shadow-sm px-4 py-3 flex items-center justify-between">
      {/* Left Section: Avatar + Info */}
      <div className="flex items-center gap-4">
        {/* Avatar with Initials */}
        <div className="w-10 h-10 rounded-full bg-green-600 text-white font-semibold text-sm flex items-center justify-center shadow-sm">
          {initials}
        </div>

        {/* Name, Phone */}
        <div className="space-y-0.5">
          <h2 className="text-base font-semibold text-gray-800">
            {displayName}
          </h2>
          {name && phoneNumber && (
            <div className="text-xs text-gray-500">{phoneNumber}</div>
          )}
        </div>
      </div>
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\ChatInput.jsx 
====================================================== 
 
import React, { useRef, useState, useCallback, useEffect } from "react";
import { useInbox } from "../InboxContext";
import { Smile, Paperclip, Send, X as CloseIcon } from "lucide-react";
import QuickReplyPicker from "./QuickReplyPicker";
import EmojiPicker from "./EmojiPicker";

export default function ChatInput() {
  const { newMessage, setNewMessage, sendMessage, isConnected } = useInbox();
  const [pickerOpen, setPickerOpen] = useState(false);
  const [emojiOpen, setEmojiOpen] = useState(false);
  const textareaRef = useRef(null);

  const clearMessage = () => setNewMessage("");

  const handleSend = () => {
    if (!isConnected || !newMessage?.trim()) return;
    setPickerOpen(false);
    setEmojiOpen(false);
    sendMessage();
    // ‚úÖ force the message list to scroll to bottom after sending
    window.dispatchEvent(new CustomEvent("xbc:scrollToBottom"));
  };

  const handleKeyDown = e => {
    if (e.key === "/" && !pickerOpen) {
      e.preventDefault();
      setPickerOpen(true);
      return;
    }
    if (e.key === "Escape" && (pickerOpen || emojiOpen)) {
      e.preventDefault();
      setPickerOpen(false);
      setEmojiOpen(false);
      return;
    }
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const insertAtCursor = useCallback(
    snippet => {
      const el = textareaRef.current;
      if (!el) {
        setNewMessage(prev => (prev ? `${prev} ${snippet}` : snippet));
        return;
      }
      const start = el.selectionStart ?? newMessage?.length ?? 0;
      const end = el.selectionEnd ?? newMessage?.length ?? 0;
      const base = newMessage ?? "";
      const next = base.slice(0, start) + snippet + base.slice(end);
      setNewMessage(next);
      requestAnimationFrame(() => {
        el.focus();
        const pos = start + snippet.length;
        el.setSelectionRange(pos, pos);
      });
    },
    [newMessage, setNewMessage]
  );

  const autoResize = useCallback(() => {
    const el = textareaRef.current;
    if (!el) return;
    el.style.height = "auto";
    const max = 160; // ~4 lines
    el.style.height = Math.min(el.scrollHeight, max) + "px";
  }, []);

  useEffect(() => {
    autoResize();
  }, [newMessage, autoResize]);

  return (
    <div className="p-3 border-t bg-white overflow-visible">
      <div className="flex items-center gap-2">
        {/* Quick Reply */}
        <div className="relative">
          <button
            type="button"
            onClick={() => setPickerOpen(v => !v)}
            className="h-9 px-3 text-sm rounded-lg border bg-white hover:bg-gray-50"
            title="Saved replies"
            disabled={!isConnected}
            aria-expanded={pickerOpen}
          >
            Quick Reply
          </button>
          {pickerOpen && (
            <div className="absolute left-0 bottom-full mb-2 z-[100]">
              <QuickReplyPicker
                onInsert={text => {
                  insertAtCursor(text);
                  setPickerOpen(false);
                }}
                onClose={() => setPickerOpen(false)}
              />
            </div>
          )}
        </div>

        {/* Emoji */}
        <div className="relative">
          <button
            type="button"
            className="h-9 w-9 flex items-center justify-center rounded-lg hover:bg-gray-100"
            title="Emoji"
            disabled={!isConnected}
            aria-expanded={emojiOpen}
            onClick={() => setEmojiOpen(v => !v)}
          >
            <Smile size={16} />
          </button>
          {emojiOpen && (
            <div className="absolute left-0 bottom-full mb-2 z-[100]">
              <EmojiPicker
                onPick={emoji => {
                  insertAtCursor(emoji);
                  setEmojiOpen(false);
                }}
                onClose={() => setEmojiOpen(false)}
              />
            </div>
          )}
        </div>

        {/* Attach (placeholder) */}
        <button
          className="h-9 w-9 flex items-center justify-center rounded-lg hover:bg-gray-100"
          title="Attach"
          disabled
        >
          <Paperclip size={16} />
        </button>

        {/* Textarea + Clear X */}
        <div className="relative flex-1">
          <textarea
            ref={textareaRef}
            rows={1}
            value={newMessage}
            onChange={e => setNewMessage(e.target.value)}
            onKeyDown={handleKeyDown}
            onInput={autoResize}
            disabled={!isConnected}
            placeholder={
              !isConnected
                ? "Connecting..."
                : "Type your message‚Ä¶ (Enter to send ‚Ä¢ Shift+Enter for new line)"
            }
            className="w-full text-sm px-4 py-2 pr-12 rounded-xl border shadow-sm focus:outline-none focus:ring-1 bg-white focus:border-purple-500 resize-none min-h-[40px] max-h-40 overflow-y-auto leading-relaxed"
          />
          {!!(newMessage || "").length && (
            <button
              type="button"
              onClick={clearMessage}
              title="Clear"
              aria-label="Clear message"
              className="absolute right-2 inset-y-0 my-auto h-6 w-6 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-500"
            >
              <CloseIcon size={16} />
            </button>
          )}
        </div>

        {/* Send */}
        <button
          onClick={handleSend}
          disabled={!isConnected || !newMessage?.trim()}
          className="h-9 w-9 flex items-center justify-center rounded-full text-white bg-green-600 hover:bg-green-700 disabled:bg-green-300 disabled:cursor-not-allowed"
          title="Send"
        >
          <Send size={16} />
        </button>
      </div>
    </div>
  );
}

// import React, { useRef, useState, useCallback, useEffect } from "react";
// import { useInbox } from "../InboxContext";
// import { Smile, Paperclip, Send, X as CloseIcon } from "lucide-react";
// import QuickReplyPicker from "./QuickReplyPicker";
// import EmojiPicker from "./EmojiPicker";

// export default function ChatInput() {
//   const { newMessage, setNewMessage, sendMessage, isConnected } = useInbox();
//   const [pickerOpen, setPickerOpen] = useState(false);
//   const [emojiOpen, setEmojiOpen] = useState(false);
//   const textareaRef = useRef(null);

//   const clearMessage = () => setNewMessage("");

//   const handleSend = () => {
//     if (!isConnected || !newMessage?.trim()) return;
//     setPickerOpen(false);
//     setEmojiOpen(false);
//     sendMessage();
//   };

//   const handleKeyDown = e => {
//     if (e.key === "/" && !pickerOpen) {
//       e.preventDefault();
//       setPickerOpen(true);
//       return;
//     }
//     if (e.key === "Escape" && (pickerOpen || emojiOpen)) {
//       e.preventDefault();
//       setPickerOpen(false);
//       setEmojiOpen(false);
//       return;
//     }
//     if (e.key === "Enter" && !e.shiftKey) {
//       e.preventDefault();
//       handleSend();
//     }
//   };

//   const insertAtCursor = useCallback(
//     snippet => {
//       const el = textareaRef.current;
//       if (!el) {
//         setNewMessage(prev => (prev ? `${prev} ${snippet}` : snippet));
//         return;
//       }
//       const start = el.selectionStart ?? newMessage?.length ?? 0;
//       const end = el.selectionEnd ?? newMessage?.length ?? 0;
//       const base = newMessage ?? "";
//       const next = base.slice(0, start) + snippet + base.slice(end);
//       setNewMessage(next);
//       requestAnimationFrame(() => {
//         el.focus();
//         const pos = start + snippet.length;
//         el.setSelectionRange(pos, pos);
//       });
//     },
//     [newMessage, setNewMessage]
//   );

//   const autoResize = useCallback(() => {
//     const el = textareaRef.current;
//     if (!el) return;
//     el.style.height = "auto";
//     const max = 160; // ~4 lines
//     el.style.height = Math.min(el.scrollHeight, max) + "px";
//   }, []);

//   useEffect(() => {
//     autoResize();
//   }, [newMessage, autoResize]);

//   return (
//     <div className="p-3 border-t bg-white overflow-visible">
//       <div className="flex items-center gap-2">
//         {/* Quick Reply */}
//         <div className="relative">
//           <button
//             type="button"
//             onClick={() => setPickerOpen(v => !v)}
//             className="h-9 px-3 text-sm rounded-lg border bg-white hover:bg-gray-50"
//             title="Saved replies"
//             disabled={!isConnected}
//             aria-expanded={pickerOpen}
//           >
//             Quick Reply
//           </button>
//           {pickerOpen && (
//             <div className="absolute left-0 bottom-full mb-2 z-[100]">
//               <QuickReplyPicker
//                 onInsert={text => {
//                   insertAtCursor(text);
//                   setPickerOpen(false);
//                 }}
//                 onClose={() => setPickerOpen(false)}
//               />
//             </div>
//           )}
//         </div>

//         {/* Emoji */}
//         <div className="relative">
//           <button
//             type="button"
//             className="h-9 w-9 flex items-center justify-center rounded-lg hover:bg-gray-100"
//             title="Emoji"
//             disabled={!isConnected}
//             aria-expanded={emojiOpen}
//             onClick={() => setEmojiOpen(v => !v)}
//           >
//             <Smile size={16} />
//           </button>
//           {emojiOpen && (
//             <div className="absolute left-0 bottom-full mb-2 z-[100]">
//               <EmojiPicker
//                 onPick={emoji => {
//                   insertAtCursor(emoji);
//                   setEmojiOpen(false);
//                 }}
//                 onClose={() => setEmojiOpen(false)}
//               />
//             </div>
//           )}
//         </div>

//         {/* Attach (placeholder) */}
//         <button
//           className="h-9 w-9 flex items-center justify-center rounded-lg hover:bg-gray-100"
//           title="Attach"
//           disabled
//         >
//           <Paperclip size={16} />
//         </button>

//         {/* Textarea + Clear X */}
//         <div className="relative flex-1">
//           <textarea
//             ref={textareaRef}
//             rows={1}
//             value={newMessage}
//             onChange={e => setNewMessage(e.target.value)}
//             onKeyDown={handleKeyDown}
//             onInput={autoResize}
//             disabled={!isConnected}
//             placeholder={
//               !isConnected
//                 ? "Connecting..."
//                 : "Type your message‚Ä¶ (Enter to send ‚Ä¢ Shift+Enter for new line)"
//             }
//             className="w-full text-sm px-4 py-2 pr-12 rounded-xl border shadow-sm focus:outline-none focus:ring-1 bg-white focus:border-purple-500 resize-none min-h-[40px] max-h-40 overflow-y-auto leading-relaxed"
//           />
//           {!!(newMessage || "").length && (
//             <button
//               type="button"
//               onClick={clearMessage}
//               title="Clear"
//               aria-label="Clear message"
//               className="absolute right-2 inset-y-0 my-auto h-6 w-6 flex items-center justify-center rounded-full hover:bg-gray-100 text-gray-500"
//             >
//               <CloseIcon size={16} />
//             </button>
//           )}
//         </div>

//         {/* Send */}
//         <button
//           onClick={handleSend}
//           disabled={!isConnected || !newMessage?.trim()}
//           className="h-9 w-9 flex items-center justify-center rounded-full text-white bg-green-600 hover:bg-green-700 disabled:bg-green-300 disabled:cursor-not-allowed"
//           title="Send"
//         >
//           <Send size={16} />
//         </button>
//       </div>
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\ChatWindow.jsx 
====================================================== 
 
import React, { useRef, useEffect, useCallback } from "react";
import { useInbox } from "../InboxContext";
import ChatBubble from "./ChatBubble";
import dayjs from "dayjs";
import isToday from "dayjs/plugin/isToday";
import isYesterday from "dayjs/plugin/isYesterday";

dayjs.extend(isToday);
dayjs.extend(isYesterday);

function getDateLabel(date) {
  const d = dayjs(date);
  if (d.isToday()) return "Today";
  if (d.isYesterday()) return "Yesterday";
  return d.format("D MMM YYYY");
}

export default function ChatWindow() {
  const { messages = [], connection, selectedContactId } = useInbox();

  // The ONLY scroll container + a bottom anchor
  const scrollContainerRef = useRef(null);
  const bottomRef = useRef(null);

  // Track if user is already at/near bottom
  const atBottomRef = useRef(true);
  const NEAR_BOTTOM_PX = 120;

  const isNearBottom = useCallback(() => {
    const el = scrollContainerRef.current;
    if (!el) return true;
    const distance = el.scrollHeight - (el.scrollTop + el.clientHeight);
    return distance <= NEAR_BOTTOM_PX;
  }, []);

  const handleScroll = useCallback(() => {
    atBottomRef.current = isNearBottom();
  }, [isNearBottom]);

  const scrollToBottom = useCallback((smooth = true) => {
    bottomRef.current?.scrollIntoView({
      behavior: smooth ? "smooth" : "auto",
      block: "end",
    });
  }, []);

  // 1) On first mount -> jump to bottom
  useEffect(() => {
    scrollToBottom(false);
    // initialize bottom state
    atBottomRef.current = true;
  }, [scrollToBottom]);

  // 2) On contact change -> jump to bottom after DOM paints
  useEffect(() => {
    const t = setTimeout(() => scrollToBottom(false), 0);
    return () => clearTimeout(t);
  }, [selectedContactId, scrollToBottom]);

  // 3) On new messages -> only scroll if already near bottom
  useEffect(() => {
    if (atBottomRef.current) scrollToBottom(true);
  }, [messages.length, scrollToBottom]);

  // 4) Allow imperative force scroll (e.g., right after Send)
  useEffect(() => {
    const onForce = () => scrollToBottom(true);
    window.addEventListener("xbc:scrollToBottom", onForce);
    return () => window.removeEventListener("xbc:scrollToBottom", onForce);
  }, [scrollToBottom]);

  // 5) Gentle auto mark-as-read shortly after switching
  useEffect(() => {
    if (!connection || !selectedContactId) return;
    const timeout = setTimeout(() => {
      connection.invoke("MarkAsRead", selectedContactId).catch(err => {
        console.warn("‚ö†Ô∏è MarkAsRead SignalR call failed:", err);
      });
    }, 800);
    return () => clearTimeout(timeout);
  }, [connection, selectedContactId]);

  if (messages.length === 0) {
    return (
      <div className="flex-1 flex items-center justify-center text-gray-400">
        Loading messages‚Ä¶
      </div>
    );
  }

  // Group by date
  const grouped = messages.reduce((acc, msg) => {
    const dateKey = getDateLabel(msg.sentAt || msg.createdAt);
    (acc[dateKey] ||= []).push(msg);
    return acc;
  }, {});

  return (
    <div
      ref={scrollContainerRef}
      onScroll={handleScroll}
      className="p-4 space-y-6 overflow-y-auto h-full"
    >
      {Object.entries(grouped).map(([date, msgs]) => (
        <div key={date}>
          <div className="text-center text-xs text-gray-500 mb-2">{date}</div>
          <div className="space-y-1">
            {msgs.map((msg, idx) => (
              <ChatBubble
                key={msg.id || idx}
                message={msg}
                isOwn={!msg.isIncoming}
              />
            ))}
          </div>
        </div>
      ))}
      <div ref={bottomRef} />
    </div>
  );
}

// import React, { useRef, useEffect } from "react";
// import { useInbox } from "../InboxContext";
// import ChatBubble from "./ChatBubble";
// import dayjs from "dayjs";
// import isToday from "dayjs/plugin/isToday";
// import isYesterday from "dayjs/plugin/isYesterday";

// dayjs.extend(isToday);
// dayjs.extend(isYesterday);

// function getDateLabel(date) {
//   const d = dayjs(date);
//   if (d.isToday()) return "Today";
//   if (d.isYesterday()) return "Yesterday";
//   return d.format("D MMM YYYY");
// }

// export default function ChatWindow() {
//   const { messages, connection, selectedContactId } = useInbox();
//   const bottomRef = useRef(null);
//   const scrollContainerRef = useRef(null);

//   // Smart scrolling
//   useEffect(() => {
//     if (!scrollContainerRef.current) return;
//     const { scrollHeight, scrollTop, clientHeight } =
//       scrollContainerRef.current;
//     if (scrollHeight - scrollTop <= clientHeight + 100) {
//       bottomRef.current?.scrollIntoView({ behavior: "smooth" });
//     }
//   }, [messages]);

//   // Mark messages as read
//   useEffect(() => {
//     if (!connection || !selectedContactId) return;
//     const timeout = setTimeout(() => {
//       connection.invoke("MarkAsRead", selectedContactId).catch(err => {
//         console.warn("‚ö†Ô∏è MarkAsRead SignalR call failed:", err);
//       });
//     }, 800);
//     return () => clearTimeout(timeout);
//   }, [connection, selectedContactId]);

//   if (messages.length === 0) {
//     return (
//       <div className="flex-1 flex items-center justify-center text-gray-400">
//         Loading messages...
//       </div>
//     );
//   }

//   const grouped = messages.reduce((acc, msg) => {
//     const dateKey = getDateLabel(msg.sentAt || msg.createdAt);
//     if (!acc[dateKey]) acc[dateKey] = [];
//     acc[dateKey].push(msg);
//     return acc;
//   }, {});

//   return (
//     <div
//       ref={scrollContainerRef}
//       className="p-4 space-y-6 overflow-y-auto h-full"
//     >
//       {Object.entries(grouped).map(([date, msgs]) => (
//         <div key={date}>
//           <div className="text-center text-xs text-gray-500 mb-2">{date}</div>
//           <div className="space-y-1">
//             {msgs.map((msg, idx) => (
//               <ChatBubble
//                 key={msg.id || idx}
//                 message={msg}
//                 isOwn={!msg.isIncoming}
//               />
//             ))}
//           </div>
//         </div>
//       ))}
//       <div ref={bottomRef} />
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\ContactSidebar.jsx 
====================================================== 
 
import React, { useEffect, useState } from "react";
import axiosClient from "../../../api/axiosClient";
// Removed Edit2 as it was unused
import { Info, StickyNote } from "lucide-react";
import dayjs from "dayjs";
import relativeTime from "dayjs/plugin/relativeTime";
dayjs.extend(relativeTime);

export default function ContactSidebar({ contactId }) {
  const [contact, setContact] = useState(null);
  const [newNote, setNewNote] = useState("");
  const [activeTab, setActiveTab] = useState("details");

  // üü£ LOG: Incoming contactId
  useEffect(() => {
    console.log("[ContactSidebar] Rendered with contactId:", contactId);
  }, [contactId]);

  useEffect(() => {
    if (!contactId) {
      console.warn("[ContactSidebar] No contactId provided");
      return;
    }

    const fetchContact = async () => {
      try {
        console.log("[ContactSidebar] Fetching contact:", contactId);
        const res = await axiosClient.get(`/contacts/${contactId}`);
        console.log("[ContactSidebar] API response:", res);

        // üü£ Some APIs wrap data in a .data.data shape!
        if (res?.data?.data) {
          setContact(res.data.data);
          console.log("[ContactSidebar] Set contact with res.data.data");
        } else if (res?.data) {
          setContact(res.data);
          console.log("[ContactSidebar] Set contact with res.data");
        } else {
          setContact(res);
          console.log("[ContactSidebar] Set contact with res");
        }
      } catch (err) {
        console.error("‚ùå [ContactSidebar] Failed to load contact:", err);
      }
    };

    fetchContact();
  }, [contactId]);

  const handleAddNote = async () => {
    if (!newNote.trim()) return;

    try {
      console.log(
        "[ContactSidebar] Adding note for contactId:",
        contactId,
        newNote
      );
      await axiosClient.post(`/notes`, {
        contactId,
        content: newNote,
      });
      setNewNote("");
      // Refetch after adding note
      const updated = await axiosClient.get(`/contacts/${contactId}`);
      if (updated?.data?.data) {
        setContact(updated.data.data);
      } else if (updated?.data) {
        setContact(updated.data);
      } else {
        setContact(updated);
      }
    } catch (err) {
      console.error("‚ùå [ContactSidebar] Failed to add note:", err);
    }
  };

  // üü£ LOG: Current contact state
  useEffect(() => {
    console.log("[ContactSidebar] Current contact state:", contact);
  }, [contact]);

  if (!contact) return <div className="p-4 text-gray-500">Loading...</div>;

  const {
    createdAt,
    tags = [],
    notes = [],
    list = "Default",
    chatWindowStatus = "Open",
    sessionStatus = "Active",
  } = contact;

  return (
    <div
      className="p-4 text-sm overflow-y-auto"
      style={{ height: "100%", maxHeight: "100%" }}
    >
      {/* üß± Tab Switcher */}
      <div className="flex mb-4 border rounded-md overflow-hidden text-sm">
        <button
          onClick={() => setActiveTab("details")}
          className={`flex-1 px-3 py-2 flex items-center justify-center gap-1 ${
            activeTab === "details"
              ? "bg-gray-200 font-semibold"
              : "bg-gray-100 hover:bg-gray-200"
          }`}
        >
          <Info size={14} /> Details
        </button>
        <button
          onClick={() => setActiveTab("notes")}
          className={`flex-1 px-3 py-2 flex items-center justify-center gap-1 ${
            activeTab === "notes"
              ? "bg-gray-200 font-semibold"
              : "bg-gray-100 hover:bg-gray-200"
          }`}
        >
          <StickyNote size={14} /> Notes
        </button>
      </div>

      {/* üìÑ Details Tab */}
      {activeTab === "details" && (
        <div className="space-y-4">
          <div className="bg-gray-50 border rounded-md p-3">
            <h4 className="text-xs font-semibold text-gray-700 mb-1">
              Conversation
            </h4>
            <div className="flex justify-between text-xs text-gray-600">
              <span>24-hour window:</span>
              <span className="text-green-600 font-medium">
                {chatWindowStatus}
              </span>
            </div>
            <div className="flex justify-between text-xs text-gray-600">
              <span>Chat session:</span>
              <span className="text-green-600 font-medium">
                {sessionStatus}
              </span>
            </div>
            <div className="flex justify-between text-xs text-gray-600">
              <span>Window ends:</span>
              <span>‚Äî</span>
            </div>
          </div>

          <div>
            <h4 className="text-xs font-semibold text-gray-700 mb-1">
              Contact data
            </h4>
            <div className="text-xs text-gray-600">
              Created: {createdAt?.slice(0, 10)}
            </div>
            <div className="text-xs text-gray-600">List: {list}</div>
          </div>

          <div>
            <h4 className="text-xs font-semibold text-gray-700 mb-1">Tags</h4>
            {tags.length === 0 ? (
              <div className="text-gray-400 italic text-xs">No tags</div>
            ) : (
              <div className="flex flex-wrap gap-2">
                {tags.map(tag => (
                  <span
                    key={tag.id}
                    className="text-xs font-medium px-2 py-1 rounded-full"
                    style={{
                      backgroundColor: tag.colorHex || "#999",
                      color:
                        tag.colorHex && tag.colorHex.toLowerCase() === "#ffffe0"
                          ? "#000"
                          : "#fff",
                    }}
                  >
                    {tag.name}
                  </span>
                ))}
              </div>
            )}
          </div>
        </div>
      )}

      {/* üìù Notes Tab */}
      {activeTab === "notes" && (
        <div className="space-y-3">
          <div className="flex gap-2">
            <input
              className="flex-1 px-2 py-1 text-xs border rounded-md"
              placeholder="Add note..."
              value={newNote}
              onChange={e => setNewNote(e.target.value)}
            />
            <button
              onClick={handleAddNote}
              className="bg-blue-600 text-white text-xs px-3 py-1 rounded-md hover:bg-blue-700"
            >
              Add
            </button>
          </div>

          {Array.isArray(notes) && notes.length > 0 ? (
            <div className="space-y-2 max-h-40 overflow-y-auto">
              {notes.map(n => (
                <div
                  key={n.id}
                  className="text-xs text-gray-700 bg-gray-100 rounded-md px-2 py-1"
                >
                  <div>{n.content}</div>
                  <div className="text-[10px] text-gray-400 mt-1">
                    {dayjs(n.createdAt).fromNow()}
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-gray-400 italic text-xs">No notes yet</div>
          )}
        </div>
      )}
    </div>
  );
}

// import React, { useEffect, useState } from "react";
// import axiosClient from "../../../api/axiosClient";
// import { Edit2, Info, StickyNote } from "lucide-react";
// import dayjs from "dayjs";
// import relativeTime from "dayjs/plugin/relativeTime";
// dayjs.extend(relativeTime);

// export default function ContactSidebar({ contactId }) {
//   const [contact, setContact] = useState(null);
//   const [newNote, setNewNote] = useState("");
//   const [activeTab, setActiveTab] = useState("details");

//   // üü£ LOG: Incoming contactId
//   useEffect(() => {
//     console.log("[ContactSidebar] Rendered with contactId:", contactId);
//   }, [contactId]);

//   useEffect(() => {
//     if (!contactId) {
//       console.warn("[ContactSidebar] No contactId provided");
//       return;
//     }

//     const fetchContact = async () => {
//       try {
//         console.log("[ContactSidebar] Fetching contact:", contactId);
//         const res = await axiosClient.get(`/contacts/${contactId}`);
//         console.log("[ContactSidebar] API response:", res);

//         // üü£ Some APIs wrap data in a .data.data shape!
//         if (res?.data?.data) {
//           setContact(res.data.data);
//           console.log("[ContactSidebar] Set contact with res.data.data");
//         } else if (res?.data) {
//           setContact(res.data);
//           console.log("[ContactSidebar] Set contact with res.data");
//         } else {
//           setContact(res);
//           console.log("[ContactSidebar] Set contact with res");
//         }
//       } catch (err) {
//         console.error("‚ùå [ContactSidebar] Failed to load contact:", err);
//       }
//     };

//     fetchContact();
//   }, [contactId]);

//   const handleAddNote = async () => {
//     if (!newNote.trim()) return;

//     try {
//       console.log(
//         "[ContactSidebar] Adding note for contactId:",
//         contactId,
//         newNote
//       );
//       await axiosClient.post(`/notes`, {
//         contactId,
//         content: newNote,
//       });
//       setNewNote("");
//       // Refetch after adding note
//       const updated = await axiosClient.get(`/contacts/${contactId}`);
//       if (updated?.data?.data) {
//         setContact(updated.data.data);
//       } else if (updated?.data) {
//         setContact(updated.data);
//       } else {
//         setContact(updated);
//       }
//     } catch (err) {
//       console.error("‚ùå [ContactSidebar] Failed to add note:", err);
//     }
//   };

//   // üü£ LOG: Current contact state
//   useEffect(() => {
//     console.log("[ContactSidebar] Current contact state:", contact);
//   }, [contact]);

//   if (!contact) return <div className="p-4 text-gray-500">Loading...</div>;

//   const {
//     name,
//     phoneNumber,
//     createdAt,
//     tags = [],
//     notes = [],
//     list = "Default",
//     chatWindowStatus = "Open",
//     sessionStatus = "Active",
//   } = contact;

//   const initials = name
//     ?.split(" ")
//     .map(n => n[0])
//     .join("")
//     .substring(0, 2)
//     .toUpperCase();

//   return (
//     <div className="p-4 text-sm overflow-y-auto h-full">
//       {/* üîπ Top Header */}
//       <div className="flex items-center gap-4 mb-4">
//         <div className="w-10 h-10 rounded-full bg-green-600 text-white flex items-center justify-center font-semibold text-sm">
//           {initials}
//         </div>
//         <div>
//           <h2 className="font-semibold text-gray-800 flex items-center gap-2">
//             {name}
//             {sessionStatus === "Active" && (
//               <span
//                 className="ml-1 inline-block w-2 h-2 rounded-full bg-green-500 animate-pulse"
//                 title="Active session"
//               ></span>
//             )}
//           </h2>
//           <div className="text-xs text-gray-500">{phoneNumber}</div>
//         </div>
//       </div>

//       {/* üß± Tab Switcher */}
//       <div className="flex mb-4 border rounded-md overflow-hidden text-sm">
//         <button
//           onClick={() => setActiveTab("details")}
//           className={`flex-1 px-3 py-2 flex items-center justify-center gap-1 ${
//             activeTab === "details"
//               ? "bg-gray-200 font-semibold"
//               : "bg-gray-100 hover:bg-gray-200"
//           }`}
//         >
//           <Info size={14} /> Details
//         </button>
//         <button
//           onClick={() => setActiveTab("notes")}
//           className={`flex-1 px-3 py-2 flex items-center justify-center gap-1 ${
//             activeTab === "notes"
//               ? "bg-gray-200 font-semibold"
//               : "bg-gray-100 hover:bg-gray-200"
//           }`}
//         >
//           <StickyNote size={14} /> Notes
//         </button>
//       </div>

//       {/* üìÑ Details Tab */}
//       {activeTab === "details" && (
//         <div className="space-y-4">
//           <div className="bg-gray-50 border rounded-md p-3">
//             <h4 className="text-xs font-semibold text-gray-700 mb-1">
//               Conversation
//             </h4>
//             <div className="flex justify-between text-xs text-gray-600">
//               <span>24-hour window:</span>
//               <span className="text-green-600 font-medium">
//                 {chatWindowStatus}
//               </span>
//             </div>
//             <div className="flex justify-between text-xs text-gray-600">
//               <span>Chat session:</span>
//               <span className="text-green-600 font-medium">
//                 {sessionStatus}
//               </span>
//             </div>
//             <div className="flex justify-between text-xs text-gray-600">
//               <span>Window ends:</span>
//               <span>‚Äî</span>
//             </div>
//           </div>

//           <div>
//             <h4 className="text-xs font-semibold text-gray-700 mb-1">
//               Contact data
//             </h4>
//             <div className="text-xs text-gray-600">
//               Created: {createdAt?.slice(0, 10)}
//             </div>
//             <div className="text-xs text-gray-600">List: {list}</div>
//           </div>

//           <div>
//             <h4 className="text-xs font-semibold text-gray-700 mb-1">Tags</h4>
//             {tags.length === 0 ? (
//               <div className="text-gray-400 italic text-xs">No tags</div>
//             ) : (
//               <div className="flex flex-wrap gap-2">
//                 {tags.map(tag => (
//                   <span
//                     key={tag.id}
//                     className="text-xs font-medium px-2 py-1 rounded-full"
//                     style={{
//                       backgroundColor: tag.colorHex || "#999",
//                       color:
//                         tag.colorHex && tag.colorHex.toLowerCase() === "#ffffe0"
//                           ? "#000"
//                           : "#fff",
//                     }}
//                   >
//                     {tag.name}
//                   </span>
//                 ))}
//               </div>
//             )}
//           </div>
//         </div>
//       )}

//       {/* üìù Notes Tab */}
//       {activeTab === "notes" && (
//         <div className="space-y-3">
//           <div className="flex gap-2">
//             <input
//               className="flex-1 px-2 py-1 text-xs border rounded-md"
//               placeholder="Add note..."
//               value={newNote}
//               onChange={e => setNewNote(e.target.value)}
//             />
//             <button
//               onClick={handleAddNote}
//               className="bg-blue-600 text-white text-xs px-3 py-1 rounded-md hover:bg-blue-700"
//             >
//               Add
//             </button>
//           </div>

//           {Array.isArray(notes) && notes.length > 0 ? (
//             <div className="space-y-2 max-h-40 overflow-y-auto">
//               {notes.map(n => (
//                 <div
//                   key={n.id}
//                   className="text-xs text-gray-700 bg-gray-100 rounded-md px-2 py-1"
//                 >
//                   <div>{n.content}</div>
//                   <div className="text-[10px] text-gray-400 mt-1">
//                     {dayjs(n.createdAt).fromNow()}
//                   </div>
//                 </div>
//               ))}
//             </div>
//           ) : (
//             <div className="text-gray-400 italic text-xs">No notes yet</div>
//           )}
//         </div>
//       )}
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\EmojiPicker.jsx 
====================================================== 
 
import React, { useEffect, useMemo, useRef, useState } from "react";

// Lightweight emoji set (common, chat-friendly)
const RAW = [
  ["üòÄ", "grinning"],
  ["üòÅ", "beaming"],
  ["üòÇ", "joy"],
  ["ü§£", "rofl"],
  ["üòä", "smile"],
  ["üôÇ", "slight_smile"],
  ["üòâ", "wink"],
  ["üòç", "heart_eyes"],
  ["üòò", "kiss"],
  ["üòã", "yum"],
  ["üòé", "cool"],
  ["ü§©", "star_struck"],
  ["ü•≥", "partying"],
  ["üòá", "innocent"],
  ["ü§ó", "hug"],
  ["üòÖ", "sweat_smile"],
  ["üòå", "relieved"],
  ["üò¥", "sleep"],
  ["ü§î", "think"],
  ["ü§®", "doubt"],
  ["üòê", "neutral"],
  ["üòÆ", "open_mouth"],
  ["üò¢", "cry"],
  ["üò≠", "sob"],
  ["üò°", "angry"],
  ["üò±", "scream"],
  ["ü§Ø", "mind_blown"],
  ["ü§í", "sick"],
  ["ü§ï", "injured"],
  ["ü§ß", "sneeze"],
  ["ü•∂", "cold"],
  ["ü•µ", "hot"],
  ["üëç", "thumbs_up"],
  ["üëé", "thumbs_down"],
  ["üôè", "pray"],
  ["üëè", "clap"],
  ["üôå", "raised_hands"],
  ["ü§ù", "handshake"],
  ["üí™", "muscle"],
  ["ü´∂", "heart_hands"],
  ["‚ù§Ô∏è", "red_heart"],
  ["üíõ", "yellow_heart"],
  ["üíö", "green_heart"],
  ["üíô", "blue_heart"],
  ["üíú", "purple_heart"],
  ["üñ§", "black_heart"],
  ["üíî", "broken_heart"],
  ["‚ú®", "sparkles"],
  ["üî•", "fire"],
  ["‚≠ê", "star"],
  ["‚úÖ", "check"],
  ["‚ùå", "cross"],
  ["‚ö†Ô∏è", "warning"],
  ["‚è≥", "hourglass"],
  ["üìå", "pin"],
  ["üìç", "round_pushpin"],
  ["üìÖ", "calendar"],
  ["üõçÔ∏è", "shopping"],
  ["üí∞", "money"],
  ["üéâ", "tada"],
  ["üéä", "confetti"],
  ["üí¨", "speech"],
  ["‚úâÔ∏è", "envelope"],
  ["üì±", "phone"],
  ["üìû", "telephone"],
  ["‚è∞", "alarm"],
  ["‚åõ", "timer"],
  ["üßæ", "receipt"],
  ["üß∞", "tools"],
  ["üß†", "brain"],
];

const EMOJIS = RAW.map(([char, name]) => ({ char, name }));

export default function EmojiPicker({ onPick, onClose }) {
  const ref = useRef(null);
  const [q, setQ] = useState("");

  // Close on outside click
  useEffect(() => {
    const onDocClick = e => {
      if (!ref.current) return;
      if (!ref.current.contains(e.target)) onClose?.();
    };
    document.addEventListener("mousedown", onDocClick, { capture: true });
    return () =>
      document.removeEventListener("mousedown", onDocClick, { capture: true });
  }, [onClose]);

  const filtered = useMemo(() => {
    const s = q.trim().toLowerCase();
    if (!s) return EMOJIS;
    return EMOJIS.filter(e => e.char.includes(s) || e.name.includes(s));
  }, [q]);

  return (
    <div
      ref={ref}
      className="w-80 rounded-xl border bg-white shadow-lg p-2"
      role="dialog"
      aria-label="Emoji picker"
    >
      <div className="flex items-center gap-2 mb-2">
        <input
          autoFocus
          className="flex-1 border rounded-md px-2 py-1 text-sm"
          placeholder="Search emoji‚Ä¶"
          value={q}
          onChange={e => setQ(e.target.value)}
          onKeyDown={e => {
            if (e.key === "Escape") onClose?.();
          }}
        />
        <button
          className="text-xs text-gray-500 hover:text-gray-700 px-2 py-1"
          onClick={() => onClose?.()}
          type="button"
        >
          Close
        </button>
      </div>

      {/* No scrollbar: wider + more columns + slightly smaller buttons */}
      <div className="grid grid-cols-10 gap-1 overflow-y-hidden">
        {filtered.map(e => (
          <button
            key={e.char + e.name}
            type="button"
            className="h-7 w-7 flex items-center justify-center rounded hover:bg-gray-100"
            title={e.name.replace(/_/g, " ")}
            onClick={() => onPick?.(e.char)}
          >
            <span className="text-lg">{e.char}</span>
          </button>
        ))}
      </div>

      {/* <div className="mt-2 text-[10px] text-gray-400 px-1">
        Tip: you can also use your OS emoji panel (Win + .) / (‚åò Ctrl Space)
      </div> */}
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\InboxSidebar.jsx 
====================================================== 
 
// ‚úÖ Final Updated InboxSidebar.jsx (auto-mark-read + refresh + sound on new unread)
import React, { useEffect, useState, useCallback } from "react";
import axiosClient from "../../../api/axiosClient";
import useSignalR from "../../../hooks/useSignalR";
import useNotificationSound from "../../../hooks/useNotificationSound"; // ‚¨ÖÔ∏è NEW

export default function InboxSidebar({ onSelect, currentUserId }) {
  const [contacts, setContacts] = useState([]);
  const [selectedId, setSelectedId] = useState(null);
  const [unreadCounts, setUnreadCounts] = useState({});
  const [search, setSearch] = useState("");
  const { connection } = useSignalR();

  // üîî Sound (autoplay-safe + throttled; uses /sounds/inbox_notify.mp3 by default)
  const { play } = useNotificationSound({
    // src: "/sounds/inbox_notify.mp3", // optional (default already this)
    volume: 0.6,
    throttleMs: 800,
  });

  const fetchUnreadCounts = useCallback(async () => {
    try {
      const res = await axiosClient.get("/inbox/unread-counts");
      setUnreadCounts(res.data || {});
      console.log("‚úÖ Unread counts refreshed");
    } catch (err) {
      console.error("‚ùå Failed to refresh unread counts:", err);
    }
  }, []);

  const loadContactsAndUnread = useCallback(async () => {
    try {
      const [contactRes, countRes] = await Promise.all([
        axiosClient.get("/contacts/all"),
        axiosClient.get("/inbox/unread-counts"),
      ]);
      setContacts(contactRes.data || []);
      setUnreadCounts(countRes.data || {});
      console.log("‚úÖ Contacts and unread counts loaded");
    } catch (err) {
      console.error("‚ùå Failed to load inbox data:", err);
    }
  }, []);

  useEffect(() => {
    console.log("üì• InboxSidebar mounted | currentUserId:", currentUserId);
    loadContactsAndUnread();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentUserId]);

  useEffect(() => {
    if (!connection) return;

    const handleUnread = payload => {
      console.log("üîî [SignalR] UnreadCountChanged:", payload);

      // server says "refresh your snapshot"
      if (payload && typeof payload === "object" && payload.refresh) {
        fetchUnreadCounts();
        return;
      }

      if (payload && typeof payload === "object") {
        setUnreadCounts(payload);
      }
    };

    connection.on("UnreadCountChanged", handleUnread);
    return () => connection.off("UnreadCountChanged", handleUnread);
  }, [connection, fetchUnreadCounts]);

  useEffect(() => {
    if (!connection) return;

    const handleMessage = async msg => {
      const cid = msg?.contactId ?? msg?.ContactId ?? null;
      if (!cid) return;

      const isIncoming =
        typeof msg?.isIncoming !== "undefined"
          ? !!msg.isIncoming
          : msg?.senderId
          ? false
          : true;

      console.log(
        "üì© [SignalR] Message:",
        msg,
        "| parsed contactId:",
        cid,
        "| isIncoming:",
        isIncoming
      );

      // Never badge on ANY outbound message
      if (!isIncoming) return;

      // If the active chat ‚Üí mark as read immediately
      if (String(cid) === String(selectedId)) {
        try {
          if (connection?.invoke) {
            await connection.invoke("MarkAsRead", cid);
            console.log("‚úÖ MarkAsRead via SignalR for", cid);
          } else {
            await axiosClient.post(`/inbox/mark-read?contactId=${cid}`);
            console.log("‚úÖ MarkAsRead fallback HTTP for", cid);
          }
        } catch (err) {
          console.error("‚ùå Failed to mark as read in active chat:", err);
        }
        return; // do not increment badge or play sound
      }

      // Otherwise, increment unread count for that contact
      setUnreadCounts(prev => ({
        ...(prev || {}),
        [cid]: (prev?.[cid] || 0) + 1,
      }));

      // üîî Play sound only when a new unread is created (non-active chat)
      try {
        play();
      } catch {}
    };

    connection.on("ReceiveInboxMessage", handleMessage);
    return () => connection.off("ReceiveInboxMessage", handleMessage);
  }, [connection, selectedId, currentUserId, play]); // include play in deps

  useEffect(() => {
    if (!connection) return;
    if (typeof connection.onreconnected === "function") {
      connection.onreconnected(() => {
        console.log("üîÅ SignalR reconnected ‚Äî reloading unread counts");
        loadContactsAndUnread();
      });
    }
  }, [connection, loadContactsAndUnread]);

  const handleSelect = async id => {
    setSelectedId(id);
    onSelect(id);

    // Optimistic reset
    setUnreadCounts(prev => ({ ...(prev || {}), [id]: 0 }));

    try {
      if (connection?.invoke) {
        await connection.invoke("MarkAsRead", id);
        console.log("‚úÖ MarkAsRead via SignalR for", id);
        return;
      }
    } catch (err) {
      console.warn("‚ö†Ô∏è SignalR MarkAsRead failed, fallback:", err);
    }

    try {
      await axiosClient.post(`/inbox/mark-read?contactId=${id}`);
      console.log("‚úÖ MarkAsRead fallback HTTP for", id);
    } catch (err) {
      console.error("‚ùå Failed to mark as read via HTTP:", err);
    }
  };

  const getInitials = name =>
    name
      ?.split(" ")
      .map(n => n[0])
      .join("")
      .substring(0, 2)
      .toUpperCase();

  const safeContacts = Array.isArray(contacts) ? contacts : [];
  const filtered = safeContacts.filter(c =>
    (c.name || c.phoneNumber || "")
      .toString()
      .toLowerCase()
      .includes(search.toLowerCase())
  );

  return (
    <div className="flex flex-col h-full">
      <div className="p-3 border-b">
        <input
          type="text"
          placeholder="Search"
          className="w-full px-3 py-2 border rounded-lg text-sm focus:outline-none focus:ring"
          value={search}
          onChange={e => setSearch(e.target.value)}
        />
      </div>

      <div className="flex-1 overflow-y-auto">
        <div className="text-sm font-semibold text-gray-700 px-4 py-2">
          Contacts
        </div>
        {filtered.map(contact => {
          const cid = String(contact.id);
          const unread = Number(unreadCounts[cid] || 0);
          return (
            <div
              key={contact.id}
              onClick={() => handleSelect(contact.id)}
              className={`flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-gray-100 ${
                selectedId === contact.id ? "bg-gray-200" : ""
              }`}
            >
              <div className="flex items-center gap-3">
                <div className="w-9 h-9 rounded-full bg-purple-600 text-xs font-semibold flex items-center justify-center text-white">
                  {getInitials(contact.name || contact.phoneNumber)}
                </div>
                <div className="flex flex-col">
                  <div className="font-medium text-sm text-gray-800 truncate">
                    {contact.name || contact.phoneNumber || "Unknown"}
                  </div>
                  {contact.name && (
                    <div className="text-xs text-gray-500">
                      {contact.phoneNumber}
                    </div>
                  )}
                </div>
              </div>
              {unread > 0 && (
                <div className="text-xs bg-purple-600 text-white px-2 py-0.5 rounded-full min-w-[20px] text-center">
                  {unread}
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}

// // ‚úÖ Final Updated InboxSidebar.jsx (active chat auto-mark-read + refresh support)
// import React, { useEffect, useState, useCallback } from "react";
// import axiosClient from "../../../api/axiosClient";
// import useSignalR from "../../../hooks/useSignalR";

// export default function InboxSidebar({ onSelect, currentUserId }) {
//   const [contacts, setContacts] = useState([]);
//   const [selectedId, setSelectedId] = useState(null);
//   const [unreadCounts, setUnreadCounts] = useState({});
//   const [search, setSearch] = useState("");
//   const { connection } = useSignalR();

//   const fetchUnreadCounts = useCallback(async () => {
//     try {
//       const res = await axiosClient.get("/inbox/unread-counts");
//       setUnreadCounts(res.data || {});
//       console.log("‚úÖ Unread counts refreshed");
//     } catch (err) {
//       console.error("‚ùå Failed to refresh unread counts:", err);
//     }
//   }, []);

//   const loadContactsAndUnread = useCallback(async () => {
//     try {
//       const [contactRes, countRes] = await Promise.all([
//         axiosClient.get("/contacts/all"),
//         axiosClient.get("/inbox/unread-counts"),
//       ]);
//       setContacts(contactRes.data || []);
//       setUnreadCounts(countRes.data || {});
//       console.log("‚úÖ Contacts and unread counts loaded");
//     } catch (err) {
//       console.error("‚ùå Failed to load inbox data:", err);
//     }
//   }, []);

//   useEffect(() => {
//     console.log("üì• InboxSidebar mounted | currentUserId:", currentUserId);
//     loadContactsAndUnread();
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [currentUserId]);

//   useEffect(() => {
//     if (!connection) return;

//     const handleUnread = payload => {
//       console.log("üîî [SignalR] UnreadCountChanged:", payload);

//       // server says "refresh your snapshot"
//       if (payload && typeof payload === "object" && payload.refresh) {
//         fetchUnreadCounts();
//         return;
//       }

//       if (payload && typeof payload === "object") {
//         setUnreadCounts(payload);
//       }
//     };

//     connection.on("UnreadCountChanged", handleUnread);
//     return () => connection.off("UnreadCountChanged", handleUnread);
//   }, [connection, fetchUnreadCounts]);

//   useEffect(() => {
//     if (!connection) return;

//     const handleMessage = async msg => {
//       const cid = msg?.contactId ?? msg?.ContactId ?? null;
//       if (!cid) return;

//       const isIncoming =
//         typeof msg?.isIncoming !== "undefined"
//           ? !!msg.isIncoming
//           : msg?.senderId
//           ? false
//           : true;

//       console.log(
//         "üì© [SignalR] Message:",
//         msg,
//         "| parsed contactId:",
//         cid,
//         "| isIncoming:",
//         isIncoming
//       );

//       // Never badge on ANY outbound message
//       if (!isIncoming) return;

//       // If the active chat ‚Üí mark as read immediately
//       if (String(cid) === String(selectedId)) {
//         try {
//           if (connection?.invoke) {
//             await connection.invoke("MarkAsRead", cid);
//             console.log("‚úÖ MarkAsRead via SignalR for", cid);
//           } else {
//             await axiosClient.post(`/inbox/mark-read?contactId=${cid}`);
//             console.log("‚úÖ MarkAsRead fallback HTTP for", cid);
//           }
//         } catch (err) {
//           console.error("‚ùå Failed to mark as read in active chat:", err);
//         }
//         return; // do not increment badge
//       }

//       // Otherwise, increment unread count for that contact
//       setUnreadCounts(prev => ({
//         ...(prev || {}),
//         [cid]: (prev?.[cid] || 0) + 1,
//       }));
//     };

//     connection.on("ReceiveInboxMessage", handleMessage);
//     return () => connection.off("ReceiveInboxMessage", handleMessage);
//   }, [connection, selectedId, currentUserId]);

//   useEffect(() => {
//     if (!connection) return;
//     if (typeof connection.onreconnected === "function") {
//       connection.onreconnected(() => {
//         console.log("üîÅ SignalR reconnected ‚Äî reloading unread counts");
//         loadContactsAndUnread();
//       });
//     }
//   }, [connection, loadContactsAndUnread]);

//   const handleSelect = async id => {
//     setSelectedId(id);
//     onSelect(id);

//     // Optimistic reset
//     setUnreadCounts(prev => ({ ...(prev || {}), [id]: 0 }));

//     try {
//       if (connection?.invoke) {
//         await connection.invoke("MarkAsRead", id);
//         console.log("‚úÖ MarkAsRead via SignalR for", id);
//         return;
//       }
//     } catch (err) {
//       console.warn("‚ö†Ô∏è SignalR MarkAsRead failed, fallback:", err);
//     }

//     try {
//       await axiosClient.post(`/inbox/mark-read?contactId=${id}`);
//       console.log("‚úÖ MarkAsRead fallback HTTP for", id);
//     } catch (err) {
//       console.error("‚ùå Failed to mark as read via HTTP:", err);
//     }
//   };

//   const getInitials = name =>
//     name
//       ?.split(" ")
//       .map(n => n[0])
//       .join("")
//       .substring(0, 2)
//       .toUpperCase();

//   const safeContacts = Array.isArray(contacts) ? contacts : [];
//   const filtered = safeContacts.filter(c =>
//     (c.name || c.phoneNumber || "")
//       .toString()
//       .toLowerCase()
//       .includes(search.toLowerCase())
//   );

//   return (
//     <div className="w-72 h-full flex flex-col border-r bg-white">
//       <div className="p-3 border-b">
//         <input
//           type="text"
//           placeholder="Search"
//           className="w-full px-3 py-2 border rounded-lg text-sm focus:outline-none focus:ring"
//           value={search}
//           onChange={e => setSearch(e.target.value)}
//         />
//       </div>

//       <div className="flex-1 overflow-y-auto">
//         <div className="text-sm font-semibold text-gray-700 px-4 py-2">
//           Contacts
//         </div>
//         {filtered.map(contact => {
//           const cid = String(contact.id);
//           const unread = Number(unreadCounts[cid] || 0);
//           return (
//             <div
//               key={contact.id}
//               onClick={() => handleSelect(contact.id)}
//               className={`flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-gray-100 ${
//                 selectedId === contact.id ? "bg-gray-200" : ""
//               }`}
//             >
//               <div className="flex items-center gap-3">
//                 <div className="w-9 h-9 rounded-full bg-purple-600 text-xs font-semibold flex items-center justify-center text-white">
//                   {getInitials(contact.name || contact.phoneNumber)}
//                 </div>
//                 <div className="flex flex-col">
//                   <div className="font-medium text-sm text-gray-800 truncate">
//                     {contact.name || contact.phoneNumber || "Unknown"}
//                   </div>
//                   {contact.name && (
//                     <div className="text-xs text-gray-500">
//                       {contact.phoneNumber}
//                     </div>
//                   )}
//                 </div>
//               </div>
//               {unread > 0 && (
//                 <div className="text-xs bg-purple-600 text-white px-2 py-0.5 rounded-full min-w-[20px] text-center">
//                   {unread}
//                 </div>
//               )}
//             </div>
//           );
//         })}
//       </div>
//     </div>
//   );
// }

// // ‚úÖ Final Updated InboxSidebar.jsx (active chat auto-mark-read + refresh support)
// import React, { useEffect, useState, useCallback } from "react";
// import axiosClient from "../../../api/axiosClient";
// import useSignalR from "../../../hooks/useSignalR";

// export default function InboxSidebar({ onSelect, currentUserId }) {
//   const [contacts, setContacts] = useState([]);
//   const [selectedId, setSelectedId] = useState(null);
//   const [unreadCounts, setUnreadCounts] = useState({});
//   const [search, setSearch] = useState("");
//   const { connection } = useSignalR();

//   // üîÑ Helper to fetch ONLY unread counts (used by refresh signal)
//   const fetchUnreadCounts = useCallback(async () => {
//     try {
//       const res = await axiosClient.get("/inbox/unread-counts");
//       setUnreadCounts(res.data || {});
//       console.log("‚úÖ Unread counts refreshed");
//     } catch (err) {
//       console.error("‚ùå Failed to refresh unread counts:", err);
//     }
//   }, []);

//   // üîÑ Helper to fetch contacts & unread counts (initial load / reconnect)
//   const loadContactsAndUnread = useCallback(async () => {
//     try {
//       const [contactRes, countRes] = await Promise.all([
//         axiosClient.get("/contacts/all"),
//         axiosClient.get("/inbox/unread-counts"),
//       ]);
//       setContacts(contactRes.data || []);
//       setUnreadCounts(countRes.data || {});
//       console.log("‚úÖ Contacts and unread counts loaded");
//     } catch (err) {
//       console.error("‚ùå Failed to load inbox data:", err);
//     }
//   }, []);

//   useEffect(() => {
//     console.log("üì• InboxSidebar mounted | currentUserId:", currentUserId);
//     loadContactsAndUnread();
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [currentUserId]);

//   // üì° Listen for server "UnreadCountChanged"
//   useEffect(() => {
//     if (!connection) return;

//     const handleUnread = payload => {
//       console.log("üîî [SignalR] UnreadCountChanged:", payload);

//       // üö¶ Refresh signal from server: { refresh: true }
//       if (payload && typeof payload === "object" && payload.refresh) {
//         fetchUnreadCounts();
//         return;
//       }

//       // Otherwise, payload is a map { [contactId]: count }
//       if (payload && typeof payload === "object") {
//         setUnreadCounts(payload);
//       }
//     };

//     connection.on("UnreadCountChanged", handleUnread);
//     return () => connection.off("UnreadCountChanged", handleUnread);
//   }, [connection, fetchUnreadCounts]);

//   // üì° Listen for incoming messages
//   useEffect(() => {
//     if (!connection) return;

//     const handleMessage = async msg => {
//       const cid = msg?.contactId ?? msg?.ContactId ?? null;
//       if (!cid) return;

//       const isIncoming =
//         typeof msg?.isIncoming !== "undefined"
//           ? !!msg.isIncoming
//           : msg?.senderId
//           ? false
//           : true;

//       console.log(
//         "üì© [SignalR] Message:",
//         msg,
//         "| parsed contactId:",
//         cid,
//         "| isIncoming:",
//         isIncoming
//       );

//       // üîï Never badge on ANY outbound message (self or other agents)
//       if (!isIncoming) {
//         return;
//       }

//       // üü¢ If message is for the currently open chat ‚Üí mark as read immediately
//       if (String(cid) === String(selectedId)) {
//         console.log(
//           "üëÅÔ∏è Message received in active chat, marking as read immediately"
//         );

//         try {
//           if (connection?.invoke) {
//             await connection.invoke("MarkAsRead", cid);
//             console.log("‚úÖ MarkAsRead invoked via SignalR for", cid);
//           } else {
//             await axiosClient.post(`/inbox/mark-read?contactId=${cid}`);
//             console.log("‚úÖ MarkAsRead fallback HTTP for", cid);
//           }
//         } catch (err) {
//           console.error("‚ùå Failed to mark as read in active chat:", err);
//         }

//         return; // don't increment badge
//       }

//       // Otherwise, increment unread count for that contact
//       setUnreadCounts(prev => ({
//         ...(prev || {}),
//         [cid]: (prev?.[cid] || 0) + 1,
//       }));
//     };

//     connection.on("ReceiveInboxMessage", handleMessage);
//     return () => connection.off("ReceiveInboxMessage", handleMessage);
//   }, [connection, selectedId, currentUserId]);

//   // üîÅ Handle reconnects ‚Üí reload contacts + counts (covers missed events)
//   useEffect(() => {
//     if (!connection) return;
//     if (typeof connection.onreconnected === "function") {
//       connection.onreconnected(() => {
//         console.log("üîÅ SignalR reconnected ‚Äî reloading unread counts");
//         loadContactsAndUnread();
//       });
//     }
//   }, [connection, loadContactsAndUnread]);

//   // ‚úÖ Selecting a contact
//   const handleSelect = async id => {
//     setSelectedId(id);
//     onSelect(id);

//     // Optimistic reset
//     setUnreadCounts(prev => ({ ...(prev || {}), [id]: 0 }));

//     try {
//       if (connection?.invoke) {
//         await connection.invoke("MarkAsRead", id);
//         console.log("‚úÖ MarkAsRead invoked via SignalR for", id);
//         return;
//       }
//     } catch (err) {
//       console.warn("‚ö†Ô∏è SignalR MarkAsRead failed, fallback:", err);
//     }

//     try {
//       await axiosClient.post(`/inbox/mark-read?contactId=${id}`);
//       console.log("‚úÖ MarkAsRead fallback HTTP for", id);
//     } catch (err) {
//       console.error("‚ùå Failed to mark as read via HTTP:", err);
//     }
//   };

//   const getInitials = name =>
//     name
//       ?.split(" ")
//       .map(n => n[0])
//       .join("")
//       .substring(0, 2)
//       .toUpperCase();

//   const safeContacts = Array.isArray(contacts) ? contacts : [];
//   const filtered = safeContacts.filter(c =>
//     (c.name || c.phoneNumber || "")
//       .toString()
//       .toLowerCase()
//       .includes(search.toLowerCase())
//   );

//   return (
//     <div className="w-72 h-full flex flex-col border-r bg-white">
//       <div className="p-3 border-b">
//         <input
//           type="text"
//           placeholder="Search"
//           className="w-full px-3 py-2 border rounded-lg text-sm focus:outline-none focus:ring"
//           value={search}
//           onChange={e => setSearch(e.target.value)}
//         />
//       </div>

//       <div className="flex-1 overflow-y-auto">
//         <div className="text-sm font-semibold text-gray-700 px-4 py-2">
//           Contacts
//         </div>
//         {filtered.map(contact => {
//           const cid = String(contact.id);
//           const unread = Number(unreadCounts[cid] || 0);
//           return (
//             <div
//               key={contact.id}
//               onClick={() => handleSelect(contact.id)}
//               className={`flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-gray-100 ${
//                 selectedId === contact.id ? "bg-gray-200" : ""
//               }`}
//             >
//               <div className="flex items-center gap-3">
//                 <div className="w-9 h-9 rounded-full bg-purple-600 text-xs font-semibold flex items-center justify-center text-white">
//                   {getInitials(contact.name || contact.phoneNumber)}
//                 </div>
//                 <div className="flex flex-col">
//                   <div className="font-medium text-sm text-gray-800 truncate">
//                     {contact.name || contact.phoneNumber || "Unknown"}
//                   </div>
//                   {contact.name && (
//                     <div className="text-xs text-gray-500">
//                       {contact.phoneNumber}
//                     </div>
//                   )}
//                 </div>
//               </div>
//               {unread > 0 && (
//                 <div className="text-xs bg-purple-600 text-white px-2 py-0.5 rounded-full min-w-[20px] text-center">
//                   {unread}
//                 </div>
//               )}
//             </div>
//           );
//         })}
//       </div>
//     </div>
//   );
// }

// // ‚úÖ Final Updated InboxSidebar.jsx (active chat auto-mark-read)
// import React, { useEffect, useState, useCallback } from "react";
// import axiosClient from "../../../api/axiosClient";
// import useSignalR from "../../../hooks/useSignalR";

// export default function InboxSidebar({ onSelect, currentUserId }) {
//   const [contacts, setContacts] = useState([]);
//   const [selectedId, setSelectedId] = useState(null);
//   const [unreadCounts, setUnreadCounts] = useState({});
//   const [search, setSearch] = useState("");
//   const { connection } = useSignalR();

//   // üîÑ Helper to fetch contacts & unread counts
//   const loadContactsAndUnread = useCallback(async () => {
//     try {
//       const [contactRes, countRes] = await Promise.all([
//         axiosClient.get("/contacts/all"),
//         axiosClient.get("/inbox/unread-counts"),
//       ]);
//       setContacts(contactRes.data || []);
//       setUnreadCounts(countRes.data || {});
//       console.log("‚úÖ Contacts and unread counts loaded");
//     } catch (err) {
//       console.error("‚ùå Failed to load inbox data:", err);
//     }
//   }, []);

//   useEffect(() => {
//     console.log("üì• InboxSidebar mounted | currentUserId:", currentUserId);
//     loadContactsAndUnread();
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [currentUserId]);

//   // üì° Listen for server "UnreadCountChanged"
//   useEffect(() => {
//     if (!connection) return;

//     const handleUnread = payload => {
//       console.log("üîî [SignalR] UnreadCountChanged:", payload);
//       if (payload && typeof payload === "object") {
//         setUnreadCounts(payload);
//       }
//     };

//     connection.on("UnreadCountChanged", handleUnread);
//     return () => connection.off("UnreadCountChanged", handleUnread);
//   }, [connection]);

//   // üì° Listen for incoming messages
//   useEffect(() => {
//     if (!connection) return;

//     const handleMessage = async msg => {
//       const cid = msg?.contactId ?? msg?.ContactId ?? null;
//       if (!cid) return;

//       const isIncoming =
//         typeof msg?.isIncoming !== "undefined"
//           ? !!msg.isIncoming
//           : msg?.senderId
//           ? false
//           : true;

//       console.log(
//         "üì© [SignalR] Message:",
//         msg,
//         "| parsed contactId:",
//         cid,
//         "| isIncoming:",
//         isIncoming
//       );

//       // Skip self/outgoing messages
//       if (
//         !isIncoming &&
//         msg.senderId &&
//         String(msg.senderId) === String(currentUserId)
//       ) {
//         console.log("‚Ü©Ô∏è Skipping self-sent message");
//         return;
//       }

//       // üü¢ If message is for the currently open chat ‚Üí mark as read immediately
//       if (String(cid) === String(selectedId)) {
//         console.log(
//           "üëÅÔ∏è Message received in active chat, marking as read immediately"
//         );

//         try {
//           if (connection?.invoke) {
//             await connection.invoke("MarkAsRead", cid);
//             console.log("‚úÖ MarkAsRead invoked via SignalR for", cid);
//           } else {
//             await axiosClient.post(`/inbox/mark-read?contactId=${cid}`);
//             console.log("‚úÖ MarkAsRead fallback HTTP for", cid);
//           }
//         } catch (err) {
//           console.error("‚ùå Failed to mark as read in active chat:", err);
//         }

//         return; // don't increment badge
//       }

//       // Otherwise, increment unread count for that contact
//       setUnreadCounts(prev => ({
//         ...prev,
//         [cid]: (prev?.[cid] || 0) + 1,
//       }));
//     };

//     connection.on("ReceiveInboxMessage", handleMessage);
//     return () => connection.off("ReceiveInboxMessage", handleMessage);
//   }, [connection, selectedId, currentUserId]);

//   // üîÅ Handle reconnects ‚Üí reload counts
//   useEffect(() => {
//     if (!connection) return;
//     if (typeof connection.onreconnected === "function") {
//       connection.onreconnected(() => {
//         console.log("üîÅ SignalR reconnected ‚Äî reloading unread counts");
//         loadContactsAndUnread();
//       });
//     }
//   }, [connection, loadContactsAndUnread]);

//   // ‚úÖ Selecting a contact
//   const handleSelect = async id => {
//     setSelectedId(id);
//     onSelect(id);

//     // Optimistic reset
//     setUnreadCounts(prev => ({ ...prev, [id]: 0 }));

//     try {
//       if (connection?.invoke) {
//         await connection.invoke("MarkAsRead", id);
//         console.log("‚úÖ MarkAsRead invoked via SignalR for", id);
//         return;
//       }
//     } catch (err) {
//       console.warn("‚ö†Ô∏è SignalR MarkAsRead failed, fallback:", err);
//     }

//     try {
//       await axiosClient.post(`/inbox/mark-read?contactId=${id}`);
//       console.log("‚úÖ MarkAsRead fallback HTTP for", id);
//     } catch (err) {
//       console.error("‚ùå Failed to mark as read via HTTP:", err);
//     }
//   };

//   const getInitials = name =>
//     name
//       ?.split(" ")
//       .map(n => n[0])
//       .join("")
//       .substring(0, 2)
//       .toUpperCase();

//   const safeContacts = Array.isArray(contacts) ? contacts : [];
//   const filtered = safeContacts.filter(c =>
//     (c.name || c.phoneNumber || "")
//       .toString()
//       .toLowerCase()
//       .includes(search.toLowerCase())
//   );

//   return (
//     <div className="w-72 h-full flex flex-col border-r bg-white">
//       <div className="p-3 border-b">
//         <input
//           type="text"
//           placeholder="Search"
//           className="w-full px-3 py-2 border rounded-lg text-sm focus:outline-none focus:ring"
//           value={search}
//           onChange={e => setSearch(e.target.value)}
//         />
//       </div>

//       <div className="flex-1 overflow-y-auto">
//         <div className="text-sm font-semibold text-gray-700 px-4 py-2">
//           Contacts
//         </div>
//         {filtered.map(contact => {
//           const cid = String(contact.id);
//           const unread = Number(unreadCounts[cid] || 0);
//           return (
//             <div
//               key={contact.id}
//               onClick={() => handleSelect(contact.id)}
//               className={`flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-gray-100 ${
//                 selectedId === contact.id ? "bg-gray-200" : ""
//               }`}
//             >
//               <div className="flex items-center gap-3">
//                 <div className="w-9 h-9 rounded-full bg-purple-600 text-xs font-semibold flex items-center justify-center text-white">
//                   {getInitials(contact.name || contact.phoneNumber)}
//                 </div>
//                 <div className="flex flex-col">
//                   <div className="font-medium text-sm text-gray-800 truncate">
//                     {contact.name || contact.phoneNumber || "Unknown"}
//                   </div>
//                   {contact.name && (
//                     <div className="text-xs text-gray-500">
//                       {contact.phoneNumber}
//                     </div>
//                   )}
//                 </div>
//               </div>
//               {unread > 0 && (
//                 <div className="text-xs bg-purple-600 text-white px-2 py-0.5 rounded-full min-w-[20px] text-center">
//                   {unread}
//                 </div>
//               )}
//             </div>
//           );
//         })}
//       </div>
//     </div>
//   );
// }

// // ‚úÖ Final Updated InboxSidebar.jsx
// import React, { useEffect, useState, useCallback } from "react";
// import axiosClient from "../../../api/axiosClient";
// import useSignalR from "../../../hooks/useSignalR";

// export default function InboxSidebar({ onSelect, currentUserId }) {
//   const [contacts, setContacts] = useState([]);
//   const [selectedId, setSelectedId] = useState(null);
//   const [unreadCounts, setUnreadCounts] = useState({});
//   const [search, setSearch] = useState("");
//   const { connection } = useSignalR();

//   // Helper to load contacts + unread counts (used on mount & reconnect)
//   const loadContactsAndUnread = useCallback(async () => {
//     try {
//       const [contactRes, countRes] = await Promise.all([
//         axiosClient.get("/contacts/all"),
//         axiosClient.get("/inbox/unread-counts"),
//       ]);
//       setContacts(contactRes.data || []);
//       setUnreadCounts(countRes.data || {});
//       console.log("‚úÖ Contacts and unread counts loaded");
//     } catch (err) {
//       console.error("‚ùå Failed to load inbox data:", err);
//     }
//   }, []);

//   useEffect(() => {
//     console.log("üì• InboxSidebar mounted | currentUserId:", currentUserId);
//     loadContactsAndUnread();
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [currentUserId]); // run on mount or when currentUserId changes

//   // Listen for server-side UnreadCountChanged pushes (authoritative state)
//   useEffect(() => {
//     if (!connection) return;

//     const handleUnread = payload => {
//       // payload expected to be a dictionary: { "<contactId>": <count>, ... }
//       console.log("üîî [SignalR] UnreadCountChanged:", payload);
//       if (payload && typeof payload === "object") {
//         setUnreadCounts(payload);
//       }
//     };

//     connection.on("UnreadCountChanged", handleUnread);

//     return () => {
//       connection.off("UnreadCountChanged", handleUnread);
//     };
//   }, [connection]);

//   // Listen for incoming messages and increment unread for the specific contact (optimistic)
//   useEffect(() => {
//     if (!connection) return;

//     const handleMessage = msg => {
//       // Normalize incoming payload fields safely
//       const contactId = msg?.contactId ?? msg?.ContactId ?? null;
//       const isIncoming = (() => {
//         if (typeof msg?.isIncoming !== "undefined") return !!msg.isIncoming;
//         if (typeof msg?.IsIncoming !== "undefined") return !!msg.IsIncoming;
//         // fallback: treat presence of senderId or message from contact as incoming
//         return msg?.senderId ? false : true;
//       })();

//       // choose a stable identifier (string)
//       const cid = contactId ? String(contactId) : null;
//       if (!cid) return;

//       console.log(
//         "üì© [SignalR] Received message:",
//         msg,
//         "parsed contactId:",
//         cid,
//         "isIncoming:",
//         isIncoming
//       );

//       // Don't increment for outgoing / self-sent messages
//       // (some payloads set isIncoming=false for messages sent by this user)
//       if (!isIncoming) {
//         // if the hub sends senderId for outgoing messages, we can check it too:
//         if (msg.senderId && String(msg.senderId) === String(currentUserId)) {
//           console.log("‚Ü©Ô∏è Skipping self-sent message");
//           return;
//         }
//         // otherwise skip any non-incoming message
//         return;
//       }

//       // If the contact is currently open, do not bump unread (they see it)
//       if (cid === selectedId) {
//         console.log("üëÅÔ∏è Contact already open, skipping increment for", cid);
//         return;
//       }

//       // Increment unread for that contact
//       setUnreadCounts(prev => {
//         const prevCount = Number(prev?.[cid] || 0);
//         const next = { ...(prev || {}) };
//         next[cid] = prevCount + 1;
//         console.log(`üî∫ Unread for ${cid} => ${next[cid]}`);
//         return next;
//       });
//     };

//     connection.on("ReceiveInboxMessage", handleMessage);

//     return () => {
//       connection.off("ReceiveInboxMessage", handleMessage);
//     };
//   }, [connection, selectedId, currentUserId]);

//   // On SignalR reconnect, reload authoritative unread counts to avoid missed events
//   useEffect(() => {
//     if (!connection) return;

//     // Some HubConnection implementations provide onreconnected
//     if (typeof connection.onreconnected === "function") {
//       connection.onreconnected(() => {
//         console.log(
//           "üîÅ SignalR reconnected ‚Äî reloading contacts & unread counts"
//         );
//         loadContactsAndUnread();
//       });
//     }

//     // Also handle general reconnect detection if available
//     if (typeof connection.onreconnecting === "function") {
//       connection.onreconnecting(() => {
//         console.log("‚ö†Ô∏è SignalR reconnecting...");
//       });
//     }

//     return () => {
//       try {
//         if (typeof connection.onreconnected === "function") {
//           // no off for onreconnected in some implementations - ignore if unavailable
//         }
//       } catch (e) {}
//     };
//   }, [connection, loadContactsAndUnread]);

//   // Handler when user selects a contact
//   // const handleSelect = async id => {
//   //   setSelectedId(id);
//   //   onSelect(id);

//   //   // Optimistically clear unread badge
//   //   setUnreadCounts(prev => ({ ...(prev || {}), [id]: 0 }));

//   //   // Tell server this user has read messages (preferred: SignalR)
//   //   try {
//   //     if (connection && typeof connection.invoke === "function") {
//   //       await connection.invoke("MarkAsRead", id);
//   //       console.log("‚úÖ MarkAsRead invoked via SignalR for", id);
//   //       return;
//   //     }
//   //   } catch (err) {
//   //     console.warn("‚ö†Ô∏è SignalR MarkAsRead failed, falling back to HTTP:", err);
//   //   }

//   //   // Fallback: HTTP endpoint (keeps backward compatibility)
//   //   try {
//   //     await axiosClient.post(`/inbox/mark-read?contactId=${id}`);
//   //     console.log("‚úÖ Marked messages as read (HTTP) for contact:", id);
//   //   } catch (err) {
//   //     console.error("‚ùå Failed to mark as read via HTTP:", err);
//   //   }
//   // };
//   const handleSelect = async id => {
//     setSelectedId(id);
//     onSelect(id);

//     setUnreadCounts(prev => ({ ...prev, [id]: 0 }));

//     try {
//       if (connection?.invoke) {
//         await connection.invoke("MarkAsRead", id);
//       }
//     } catch {
//       await axiosClient.post(`/inbox/mark-read?contactId=${id}`);
//     }
//   };

//   const getInitials = name =>
//     name
//       ?.split(" ")
//       .map(n => n[0])
//       .join("")
//       .substring(0, 2)
//       .toUpperCase();

//   const safeContacts = Array.isArray(contacts) ? contacts : [];
//   const filtered = safeContacts.filter(c =>
//     (c.name || c.phoneNumber || "")
//       .toString()
//       .toLowerCase()
//       .includes(search.toLowerCase())
//   );

//   return (
//     <div className="w-72 h-full flex flex-col border-r bg-white">
//       <div className="p-3 border-b">
//         <input
//           type="text"
//           placeholder="Search"
//           className="w-full px-3 py-2 border rounded-lg text-sm focus:outline-none focus:ring"
//           value={search}
//           onChange={e => setSearch(e.target.value)}
//         />
//       </div>

//       <div className="flex-1 overflow-y-auto">
//         <div className="text-sm font-semibold text-gray-700 px-4 py-2">
//           Contacts
//         </div>
//         {filtered.map(contact => {
//           const cid = String(contact.id);
//           const unread = Number(unreadCounts[cid] || 0);
//           // debug log (can remove later)
//           // console.log(`üîç Rendering ${contact.id} | unread: ${unread}`);
//           return (
//             <div
//               key={contact.id}
//               onClick={() => handleSelect(contact.id)}
//               className={`flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-gray-100 ${
//                 selectedId === contact.id ? "bg-gray-200" : ""
//               }`}
//             >
//               <div className="flex items-center gap-3">
//                 <div className="w-9 h-9 rounded-full bg-purple-600 text-xs font-semibold flex items-center justify-center text-white">
//                   {getInitials(contact.name || contact.phoneNumber)}
//                 </div>
//                 <div className="flex flex-col">
//                   <div className="font-medium text-sm text-gray-800 truncate">
//                     {contact.name || contact.phoneNumber || "Unknown"}
//                   </div>
//                   {contact.name && (
//                     <div className="text-xs text-gray-500">
//                       {contact.phoneNumber}
//                     </div>
//                   )}
//                 </div>
//               </div>
//               {unread > 0 && (
//                 <div className="text-xs bg-purple-600 text-white px-2 py-0.5 rounded-full min-w-[20px] text-center">
//                   {unread}
//                 </div>
//               )}
//             </div>
//           );
//         })}
//       </div>
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\Inbox\components\QuickReplyPicker.jsx 
====================================================== 
 
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import axiosClient from "../../../api/axiosClient";

/**
 * QuickReplyPicker
 * Props:
 *  - onInsert(text: string): required
 *  - onClose(): optional
 *  - scope?: "Business" | "Personal" | "All"  // initial view; default "All"
 */
export default function QuickReplyPicker({ onInsert, onClose, scope = "All" }) {
  const containerRef = useRef(null);
  const searchRef = useRef(null);

  const [q, setQ] = useState("");
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1);

  // scope chips
  const [viewScope, setViewScope] = useState(() => scope || "All");
  const viewScopeParam = useMemo(() => {
    const s = (viewScope || "All").toString().toLowerCase();
    return s === "business" || s === "personal" ? s : "all";
  }, [viewScope]);

  // NEW: create mode
  const [creating, setCreating] = useState(false);
  const [title, setTitle] = useState("");
  const [body, setBody] = useState("");
  const [tagsCsv, setTagsCsv] = useState("");
  const [createScope, setCreateScope] = useState("Personal"); // default personal
  const [saving, setSaving] = useState(false);
  const [saveMsg, setSaveMsg] = useState("");

  // Debounced fetch when search or scope changes
  useEffect(() => {
    if (creating) return; // pause list fetch while creating
    let ignore = false;
    setLoading(true);

    const t = setTimeout(() => {
      const params = {};
      if (q) params.q = q;
      if (viewScopeParam) params.scope = viewScopeParam;

      axiosClient
        .get("/quick-replies", { params })
        .then(res => {
          if (ignore) return;
          setItems(Array.isArray(res.data) ? res.data : []);
          setActiveIndex(-1);
        })
        .catch(() => {
          if (ignore) return;
          setItems([]);
        })
        .finally(() => !ignore && setLoading(false));
    }, 200);

    return () => {
      clearTimeout(t);
      ignore = true;
    };
  }, [q, viewScopeParam, creating]);

  // Autofocus search on open
  useEffect(() => {
    searchRef.current?.focus();
  }, []);

  // Close on click outside
  useEffect(() => {
    const onDocClick = e => {
      if (!containerRef.current) return;
      if (!containerRef.current.contains(e.target)) onClose?.();
    };
    document.addEventListener("mousedown", onDocClick, { capture: true });
    return () =>
      document.removeEventListener("mousedown", onDocClick, { capture: true });
  }, [onClose]);

  const handleInsert = useCallback(
    text => {
      if (!text) return;
      onInsert?.(text);
    },
    [onInsert]
  );

  const handleKeyDown = e => {
    if (e.key === "Escape") {
      e.preventDefault();
      if (creating) {
        setCreating(false);
        return;
      }
      onClose?.();
      return;
    }
    if (creating) return; // no list nav while in create form
    if (e.key === "ArrowDown") {
      e.preventDefault();
      setActiveIndex(i => Math.min(i + 1, Math.max(0, items.length - 1)));
      return;
    }
    if (e.key === "ArrowUp") {
      e.preventDefault();
      setActiveIndex(i => Math.max(i - 1, -1));
      return;
    }
    if (e.key === "Enter") {
      if (activeIndex >= 0 && activeIndex < items.length) {
        e.preventDefault();
        handleInsert(items[activeIndex]?.body);
        onClose?.();
      }
    }
  };

  const handleCreate = async () => {
    setSaveMsg("");
    if (!title.trim() || !body.trim()) {
      setSaveMsg("Title and Body are required.");
      return;
    }
    setSaving(true);
    try {
      const payload = {
        title: title.trim(),
        body: body,
        tagsCsv: tagsCsv.trim() || null,
        scope: createScope === "Business" ? 2 : 0, // enum: Personal=0, Business=2
      };
      const res = await axiosClient.post("/quick-replies", payload);
      const ok = res?.data?.success === true;
      setSaveMsg(ok ? "‚úÖ Saved." : res?.data?.message || "‚ùå Failed to save.");
      if (ok) {
        // reset form and refresh list to created scope
        setTitle("");
        setBody("");
        setTagsCsv("");
        setCreating(false);
        setViewScope(createScope);
        setQ(""); // clear search
      }
    } catch (err) {
      setSaveMsg("‚ùå Failed to save.");
      // optional: console.error(err);
    } finally {
      setSaving(false);
    }
  };

  return (
    <div
      ref={containerRef}
      className="w-80 rounded-xl border bg-white shadow-lg p-2"
      role="dialog"
      aria-label="Quick replies"
    >
      {/* Header row: search + actions */}
      <div className="flex items-center gap-2 mb-2">
        {!creating ? (
          <>
            <input
              ref={searchRef}
              className="flex-1 border rounded-md px-2 py-1 text-sm"
              placeholder="Search saved replies‚Ä¶"
              value={q}
              onChange={e => setQ(e.target.value)}
              onKeyDown={handleKeyDown}
            />
            <button
              className="text-xs px-2 py-1 border rounded-md bg-white hover:bg-gray-50"
              onClick={() => setCreating(true)}
              type="button"
              title="Create a new quick reply"
            >
              New
            </button>
            <button
              className="text-xs text-gray-500 hover:text-gray-700 px-2 py-1"
              onClick={() => onClose?.()}
              type="button"
            >
              Close
            </button>
          </>
        ) : (
          <>
            <div className="text-sm font-medium">New quick reply</div>
            <div className="flex-1" />
            <button
              className="text-xs text-gray-500 hover:text-gray-700 px-2 py-1"
              onClick={() => setCreating(false)}
              type="button"
            >
              Cancel
            </button>
          </>
        )}
      </div>

      {/* Scope chips (list view) OR Create form */}
      {!creating ? (
        <>
          {/* Scope chips */}
          <div className="flex items-center gap-1 mb-2 px-1">
            {["All", "Business", "Personal"].map(s => (
              <button
                key={s}
                type="button"
                onClick={() => setViewScope(s)}
                className={`px-2 py-0.5 text-xs rounded-full border ${
                  viewScope === s ? "bg-gray-200" : "bg-white hover:bg-gray-100"
                }`}
              >
                {s}
              </button>
            ))}
          </div>

          <div className="max-h-64 overflow-y-auto">
            {loading && (
              <div className="text-xs text-gray-500 p-2">Loading‚Ä¶</div>
            )}
            {!loading && items.length === 0 && (
              <div className="text-xs text-gray-500 p-2">No results</div>
            )}

            {!loading &&
              items.map((x, idx) => {
                const isActive = idx === activeIndex;
                return (
                  <button
                    key={x.id}
                    type="button"
                    className={`w-full text-left p-2 rounded-md ${
                      isActive ? "bg-gray-200" : "hover:bg-gray-100"
                    }`}
                    onMouseEnter={() => setActiveIndex(idx)}
                    onClick={() => {
                      handleInsert(x.body);
                      onClose?.();
                    }}
                    title={x.tagsCsv || ""}
                  >
                    <div className="text-sm font-medium text-gray-800">
                      {x.title}
                    </div>
                    <div className="text-xs text-gray-600 line-clamp-2">
                      {x.body}
                    </div>
                    {x.language && (
                      <div className="text-[10px] text-gray-400 mt-1">
                        Lang: {x.language}
                      </div>
                    )}
                  </button>
                );
              })}
          </div>

          <div className="flex items-center justify-between mt-2 px-1">
            <div className="text-[10px] text-gray-400">
              Scope: <span className="uppercase">{viewScopeParam}</span>
            </div>
            <div className="text-[10px] text-gray-400">
              ‚Üë/‚Üì navigate ‚Ä¢ Enter insert ‚Ä¢ Esc close
            </div>
          </div>
        </>
      ) : (
        // CREATE FORM
        <div className="space-y-2">
          <div className="flex items-center gap-2">
            <label className="text-xs text-gray-600 w-16">Scope</label>
            <div className="flex items-center gap-2">
              {["Personal", "Business"].map(s => (
                <label key={s} className="text-xs flex items-center gap-1">
                  <input
                    type="radio"
                    name="qr-scope"
                    value={s}
                    checked={createScope === s}
                    onChange={() => setCreateScope(s)}
                  />
                  {s}
                </label>
              ))}
            </div>
          </div>

          <div className="flex items-center gap-2">
            <label className="text-xs text-gray-600 w-16">Title</label>
            <input
              className="flex-1 border rounded-md px-2 py-1 text-sm"
              value={title}
              onChange={e => setTitle(e.target.value)}
              placeholder="e.g., Greeting (EN)"
            />
          </div>

          <div className="flex items-start gap-2">
            <label className="text-xs text-gray-600 w-16 mt-1">Body</label>
            <textarea
              className="flex-1 border rounded-md px-2 py-1 text-sm h-24"
              value={body}
              onChange={e => setBody(e.target.value)}
              placeholder="Type the message‚Ä¶"
            />
          </div>

          <div className="flex items-center gap-2">
            <label className="text-xs text-gray-600 w-16">Tags</label>
            <input
              className="flex-1 border rounded-md px-2 py-1 text-sm"
              value={tagsCsv}
              onChange={e => setTagsCsv(e.target.value)}
              placeholder="e.g., greeting,eng"
            />
          </div>

          {saveMsg && (
            <div className="text-xs px-2 py-1 rounded-md bg-gray-50 border">
              {saveMsg}
            </div>
          )}

          <div className="flex items-center justify-end gap-2">
            <button
              className="text-xs px-3 py-1 rounded-md border bg-white hover:bg-gray-50"
              onClick={() => setCreating(false)}
              type="button"
              disabled={saving}
            >
              Cancel
            </button>
            <button
              className="text-xs px-3 py-1 rounded-md text-white bg-purple-600 hover:bg-purple-700 disabled:bg-purple-300"
              onClick={handleCreate}
              type="button"
              disabled={saving}
            >
              {saving ? "Saving‚Ä¶" : "Save"}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// import React, {
//   useCallback,
//   useEffect,
//   useMemo,
//   useRef,
//   useState,
// } from "react";
// import axiosClient from "../../../api/axiosClient";

// /**
//  * QuickReplyPicker
//  * Props:
//  *  - onInsert(text: string): required
//  *  - onClose(): optional
//  *  - scope?: "Business" | "Personal" | "All"  // acts as the initial scope; default: "All"
//  */
// export default function QuickReplyPicker({ onInsert, onClose, scope = "All" }) {
//   const containerRef = useRef(null);
//   const searchRef = useRef(null);

//   const [q, setQ] = useState("");
//   const [items, setItems] = useState([]);
//   const [loading, setLoading] = useState(false);
//   const [activeIndex, setActiveIndex] = useState(-1);

//   // NEW: local scope state (chips control this)
//   const [viewScope, setViewScope] = useState(() => scope || "All");

//   const viewScopeParam = useMemo(() => {
//     const s = (viewScope || "All").toString().toLowerCase();
//     return s === "business" || s === "personal" ? s : "all";
//   }, [viewScope]);

//   // Debounced fetch when search or scope changes
//   useEffect(() => {
//     let ignore = false;
//     setLoading(true);

//     const t = setTimeout(() => {
//       const params = {};
//       if (q) params.q = q;
//       if (viewScopeParam) params.scope = viewScopeParam;

//       axiosClient
//         .get("/quick-replies", { params })
//         .then(res => {
//           if (ignore) return;
//           setItems(Array.isArray(res.data) ? res.data : []);
//           setActiveIndex(-1);
//         })
//         .catch(() => {
//           if (ignore) return;
//           setItems([]);
//         })
//         .finally(() => !ignore && setLoading(false));
//     }, 200);

//     return () => {
//       clearTimeout(t);
//       ignore = true;
//     };
//   }, [q, viewScopeParam]);

//   // Autofocus search on open
//   useEffect(() => {
//     searchRef.current?.focus();
//   }, []);

//   // Close on click outside
//   useEffect(() => {
//     const onDocClick = e => {
//       if (!containerRef.current) return;
//       if (!containerRef.current.contains(e.target)) onClose?.();
//     };
//     document.addEventListener("mousedown", onDocClick, { capture: true });
//     return () =>
//       document.removeEventListener("mousedown", onDocClick, { capture: true });
//   }, [onClose]);

//   const handleInsert = useCallback(
//     text => {
//       if (!text) return;
//       onInsert?.(text);
//     },
//     [onInsert]
//   );

//   const handleKeyDown = e => {
//     if (e.key === "Escape") {
//       e.preventDefault();
//       onClose?.();
//       return;
//     }
//     if (e.key === "ArrowDown") {
//       e.preventDefault();
//       setActiveIndex(i => Math.min(i + 1, Math.max(0, items.length - 1)));
//       return;
//     }
//     if (e.key === "ArrowUp") {
//       e.preventDefault();
//       setActiveIndex(i => Math.max(i - 1, -1));
//       return;
//     }
//     if (e.key === "Enter") {
//       if (activeIndex >= 0 && activeIndex < items.length) {
//         e.preventDefault();
//         handleInsert(items[activeIndex]?.body);
//         onClose?.();
//       }
//     }
//   };

//   return (
//     <div
//       ref={containerRef}
//       className="w-80 rounded-xl border bg-white shadow-lg p-2"
//       role="dialog"
//       aria-label="Quick replies"
//     >
//       {/* Header row: search + close */}
//       <div className="flex items-center gap-2 mb-2">
//         <input
//           ref={searchRef}
//           className="flex-1 border rounded-md px-2 py-1 text-sm"
//           placeholder="Search saved replies‚Ä¶"
//           value={q}
//           onChange={e => setQ(e.target.value)}
//           onKeyDown={handleKeyDown}
//         />
//         <button
//           className="text-xs text-gray-500 hover:text-gray-700 px-2 py-1"
//           onClick={() => onClose?.()}
//           type="button"
//         >
//           Close
//         </button>
//       </div>

//       {/* NEW: Scope chips inside the picker */}
//       <div className="flex items-center gap-1 mb-2 px-1">
//         {["All", "Business", "Personal"].map(s => (
//           <button
//             key={s}
//             type="button"
//             onClick={() => setViewScope(s)}
//             className={`px-2 py-0.5 text-xs rounded-full border ${
//               viewScope === s ? "bg-gray-200" : "bg-white hover:bg-gray-100"
//             }`}
//           >
//             {s}
//           </button>
//         ))}
//       </div>

//       <div className="max-h-64 overflow-y-auto">
//         {loading && <div className="text-xs text-gray-500 p-2">Loading‚Ä¶</div>}
//         {!loading && items.length === 0 && (
//           <div className="text-xs text-gray-500 p-2">No results</div>
//         )}

//         {!loading &&
//           items.map((x, idx) => {
//             const isActive = idx === activeIndex;
//             return (
//               <button
//                 key={x.id}
//                 type="button"
//                 className={`w-full text-left p-2 rounded-md ${
//                   isActive ? "bg-gray-200" : "hover:bg-gray-100"
//                 }`}
//                 onMouseEnter={() => setActiveIndex(idx)}
//                 onClick={() => {
//                   handleInsert(x.body);
//                   onClose?.();
//                 }}
//                 title={x.tagsCsv || ""}
//               >
//                 <div className="text-sm font-medium text-gray-800">
//                   {x.title}
//                 </div>
//                 <div className="text-xs text-gray-600 line-clamp-2">
//                   {x.body}
//                 </div>
//                 {x.language && (
//                   <div className="text-[10px] text-gray-400 mt-1">
//                     Lang: {x.language}
//                   </div>
//                 )}
//               </button>
//             );
//           })}
//       </div>

//       <div className="flex items-center justify-between mt-2 px-1">
//         <div className="text-[10px] text-gray-400">
//           Scope: <span className="uppercase">{viewScopeParam}</span>
//         </div>
//         <div className="text-[10px] text-gray-400">
//           ‚Üë/‚Üì navigate ‚Ä¢ Enter insert ‚Ä¢ Esc close
//         </div>
//       </div>
//     </div>
//   );
// }
 
 
